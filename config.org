# -*- after-save-hook: (lambda () (compile "./bootstrap-config.el")); eval: (message "Welcome to ECFPAW's literate configuration."); -*-
#+TITLE: Emacs Configuration For Programming And Writing (ECFPAW)
#+AUTHOR: tusharhero
#+EMAIL: tusharhero@sdf.org
#+DESCRIPTION: It actually does more than just programming and writing.
#+STARTUP: content
#+PROPERTY: header-args :tangle init.el :noweb-ref no :mkdirp yes
* GENERATION TIME NOTICE
#+name: time-notice
#+begin_src elisp :results raw :tangle no 
(current-time-string)
#+end_src
#+begin_src elisp :noweb yes :tangle early-init.el
  ;; This file is a part of ECFPAW,
  ;; configuration was generated by Emacs Org-Mode on `<<time-notice()>>`
#+end_src
#+begin_src elisp :noweb yes :tangle init.el
  ;; This file is a part of ECFPAW,
  ;; configuration was generated by Emacs Org-Mode on `<<time-notice()>>`
#+end_src
* LICENSE NOTICE
  :PROPERTIES:
  :VISIBILITY: folded
  :END:
#+begin_src elisp
  ;; The GPLv3 License (GPLv3)

  ;; Copyright Â© 2023-2025 tusharhero

  ;; This program is free software: you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with this program.  If not, see <http://www.gnu.org/licenses/>.
#+end_src

* TODO CHORES [1/5]
** TODO Use =use-package= properly to reduce startup time.
** TODO Add more key bindings.
*** TODO Add shortcut to bold, italicize, etc. in [[ORG-MODE]].
** TODO Correct the key bindings for annot-list mode.
** TODO Divide this TODO into respective categories in their correct place.
** DONE Completely overhaul the way I do keybindings.
* BOOTSTRAPPING
#+begin_src elisp :tangle bootstrap-config.el :shebang #!/bin/env -S emacs --script
  ;; Run this script to 'bootstrap' ECFPAW from `config.org', of course
  ;; the only requirement it has is Emacs itself.
  (message "Loading Org...")
  (require 'org)
  (setopt org-confirm-babel-evaluate nil)
  (message "Tangling config.org...")
  (org-babel-tangle-file "config.org")
  (message "ECFPAW has been bootstrapped!")
#+end_src
* Startup Optimization
It took 2.7-3 seconds before these optimizations, and now it is 1
seconds.
** Garbage collection
Minimize garbage collection before startup and then go back to the
default value (8 MiB) after startup.
#+begin_src elisp :tangle early-init.el
  (setq gc-cons-threshold-default gc-cons-threshold)
  (setq gc-cons-threshold most-positive-fixnum)
  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold gc-cons-threshold-default)))
#+end_src
* Package manager settings
I used to use =Elpaca= package manager. Although, it gave excellent
startup times, it didn't install the info manuals when available. And
I didn't really use any of its advanced features other than what was
already available built in anyway.
#+begin_src elisp
  (require 'package)
  (package-initialize)
#+end_src

Make sure =use-package= is installed. Got this snippet from [[https://protesilaos.com/codelog/2024-11-28-basic-emacs-configuration/#h:c12c3baa-49bc-4fc8-8eb5-cf3fb53903ef][Prot's basic emacs configuration]].
#+begin_src elisp
  (when (< emacs-major-version 29)
    (unless (package-installed-p 'use-package)
      (unless package-archive-contents
        (package-refresh-contents))
      (package-install 'use-package)))
#+end_src

This makes sure that Emacs installs any package that is not available.
#+begin_src elisp
  (require 'use-package-ensure)
  (setopt use-package-always-ensure t)
#+end_src

This informs you if any use-package declaration took longer than 0.1
seconds.
#+begin_src elisp
  (setopt use-package-verbose t)
#+end_src

This stops Emacs from just loading all the packages at startup. (We
use use-package to load the packages as we wish, so we don't need
this.)
#+begin_src elisp :tangle early-init.el
(setopt package-enable-at-startup nil)
#+end_src

Enables =M-x use-package-report RET= which is helpful in determining which
packages take the longest to load.
#+begin_src elisp
(setopt use-package-compute-statistics t)
#+end_src

I was missing the feature from Elpaca which allows you try out a
package without installing it.
#+begin_src elisp
  (use-package try :defer t
    :vc (:url "https://github.com/larstvei/Try.git"))
#+end_src
* Custom interface
Put all custom configuration into =custom.el=, else it will put
everything in init.el which gets removed every time we tangle.
#+begin_src elisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (if (file-exists-p custom-file)
      (load custom-file))
#+end_src
* Generally useful helper functions
There functions are generally useful.
#+begin_src elisp
  (defun ECFPAW/make-cyclic-list (list)
    "Create a cyclic list."
    (when list
      (setf (cdr (last list)) list)))
#+end_src

#+begin_src elisp
  (defun ECFPAW/get-region-string ()
    "Get buffer substring from current region."
    (buffer-substring-no-properties
     (region-beginning)
     (region-end)))
#+end_src
* DISABLE BELL
It's very annoying to have that bell ringing all the time.
#+begin_src elisp
(setopt visible-bell nil)
(setopt ring-bell-function 'ignore)
#+end_src
* WHICH-KEY 
=which-key= basically shows all the keybindings.
#+begin_src elisp
  (use-package which-key
    :init (which-key-mode)
    :bind ("C-c l" . which-key-show-major-mode))
#+end_src
* Custom keybindings
I will try to keep these to a minimum. Setting up custom keybindings
and maintaining them is a headache.
** Org
#+begin_src elisp
  (keymap-global-set "C-c a" 'org-agenda)
  (keymap-global-set "C-c c" 'org-capture)
#+end_src
* Key Statistics
I need to get some keybinding statistics to improve my keybindings situation.
#+begin_src elisp
  (use-package keyfreq
    :vc (:url "https://github.com/dacap/keyfreq.git")
    :config (keyfreq-mode 1)
    (keyfreq-autosave-mode 1))
#+end_src
* GRAPHICS
** Nerd Icons
This uses nerd icons for various things inside Emacs. Since I already
use ~Iosevka nerd font~ for this configuration it makes sense to use this.

This also has the advantage of working flawlessly in the terminal!

Although it shouldn't be needed, if you see that the icons do not
display, it you might have to install these icons using =M-x
nerd-icons-install-fonts yes RET=.

I used to use =all-the-icons= before this, but that was inferior to nerd
icons because it behaved weirdly inside the terminal.
#+begin_src emacs-lisp
  (use-package nerd-icons
    :vc (:url "https://github.com/rainstormstudio/nerd-icons.el.git"))

  (use-package nerd-icons-dired
    :vc (:url "https://github.com/rainstormstudio/nerd-icons-dired.git")
    :hook (dired-mode . nerd-icons-dired-mode))
#+end_src

This package needs to load after =marginalia-mode=, otherwise the icons
won't show up in =fido= completion menu.
#+begin_src emacs-lisp
  (use-package nerd-icons-completion
    :vc (:url "https://github.com/rainstormstudio/nerd-icons-completion.git")
    :after marginalia
    :hook (marginalia-mode . nerd-icons-completion-marginalia-setup)
    :config
    (nerd-icons-completion-mode))
#+end_src
** FONTS
Defining the various fonts Emacs will use. For now, I don't set a
variable pitch font and let Emacs select one.
#+begin_src elisp
  (let ((mono-spaced-font "Iosevka Nerd Font"))
    (set-face-attribute 'default nil :family mono-spaced-font :height 140)
    (set-face-attribute 'fixed-pitch nil :family mono-spaced-font :height 1.0))
#+end_src
** GRAPHICAL USER INTERFACE TWEAKS
Let's make GNU Emacs look a little better.

Mostly just disabling some Emacs features which are for beginners(mostly).
*** Disable Menu bar and Toolbars 
Just too distracting.
#+begin_src elisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
#+end_src
*** Disable the scroll bar
Because they are totally unnecessary and I don't use them. Even if I
ever wanted to use my mouse, I would just use my mouse wheel instead
of this.
#+begin_src elisp
  (scroll-bar-mode -1)
#+end_src
*** Start in maximised mode
#+begin_src elisp
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src
*** Disable comp warnings
#+begin_src elisp
  (custom-set-variables '(warning-suppress-types '((comp))))
#+end_src
** Spacious Padding
Oh, man this single-handedly makes ECFPAW look so much better. Thanks Prot!
#+begin_src elisp
  (use-package spacious-padding
     :config (spacious-padding-mode t))
#+end_src
** Pulsar
=Pulsar= provides the sweet *pulsing* of light you see when you switch you
buffers, or go to a place in the buffer. It's super nice for knowing
where you are.

=pulsar-pulse-region-functions= is a new feature which pulses the region
you just acted on, super nice.

I have adjust =pulsar-delay= and =pulsar-iterations= to make them
smoother. Divide default value =pulsar-delay= by 5, and multiply the
default of =pulsar-iterations= by 5.
#+begin_src elisp
  (use-package pulsar
    :defer nil
    :hook ((next-error . pulsar-pulse-line)
  	 (minibuffer-setup . pulsar-pulse-line)
  	 (imenu-after-jump . pulsar-recenter-top)
  	 (imenu-after-jump . pulsar-reveal-entry))
    :custom
    (pulsar-delay 0.01)
    (pulsar-iterations 50)
    (pulsar-pulse-region-functions
     (append pulsar-pulse-region-common-functions
  	   '(upcase-word
  	     downcase-word
  	     capitalize-word
  	     fill-paragraph
  	     org-fill-paragraph)))
    :config
    (pulsar-global-mode))
#+end_src
** THEME
I use Modus themes.
*** Ef-themes
#+begin_src elisp
  (use-package ef-themes
    :defer t
    :custom (ef-themes-mixed-fonts t))
#+end_src
*** Modus-themes
#+begin_src elisp
  (setopt modus-themes-mixed-fonts t)
  (setopt modus-themes-common-palette-overrides
  	'((fg-region unspecified)))
#+end_src
*** Easy cycling
:TODO:
+ [ ] Figure out a way to automatically wait for the correct package to
  load before running ~ECFPAW/cycle-theme~, I tried doing it using
  this code, but that does not really work.
  #+begin_src elisp :tangle no
  (with-eval-after-load (car ECFPAW/themes)
    (ECFPAW/cycle-my-theme))
  #+end_src
:END:
I have a custom function for loading and cycling through my preferred themes.
#+begin_src elisp
  (setq custom-safe-themes t)
  (advice-add 'load-theme
              :before (lambda (theme &optional no-confirm no-enable)
                        (disable-theme (car custom-enabled-themes))))
#+end_src
*** Day and night switching
I used to use circadian for this, but that was just too bloated
(according to use-package-report it would take a long time to load).
So I just roll my own now.
#+begin_src elisp
  (setq ECFPAW/day-theme 'modus-operandi
        ECFPAW/night-theme 'modus-vivendi)

  (setq ECFPAW/day-start "6:00"
        ECFPAW/day-end "18:00")

  (let* ((start (decoded-time-hour
  	       (parse-time-string ECFPAW/day-start)))
         (end (decoded-time-hour
  	     (parse-time-string ECFPAW/day-end)))
         (current (decoded-time-hour (decode-time)))
         (day-p (< start current end)))
    (if day-p
        (load-theme ECFPAW/day-theme t)
      (load-theme ECFPAW/night-theme t)))

  (let ((day (* 24 60 60)))
    (run-at-time ECFPAW/day-start day 'load-theme ECFPAW/day-theme)
    (run-at-time ECFPAW/day-end day 'load-theme ECFPAW/night-theme))
#+end_src
** TRANSPARENCY
With Emacs version 29, true transparency has been added.
*** Setting initial transparency
#+begin_src elisp
  (add-to-list 'default-frame-alist '(alpha-background . 100)) ; For all new frames henceforth
#+end_src
*** Function to change the transparency of the current frame.
**** COMMENT Xorg
I should be modifying =alpha-background= but that doesn't seem to be
going well. So I will modify =alpha= instead. =alpha-background= just
changes the background transparency, =alpha= on the other hand changes
the transparency of the entire buffer. For now the only way to get
background transparency is to modify the variable in the above
function and make a frame unfortunately.
#+begin_src elisp
  (defun ECFPAW/change-current-transparency-to (alpha-val)
    "Change the transparency to the given value"
    (interactive "nChange transparency: ")
    (set-frame-parameter (selected-frame) 'alpha alpha-val))
#+end_src
**** Wayland
This works only on Wayland, So disable it and enable the block above.
#+begin_src elisp
  (defun ECFPAW/change-current-transparency-to (alpha-val)
    "Change the transparency to the given value"
    (interactive "nChange transparency: ")
    (set-frame-parameter (selected-frame) 'alpha-background alpha-val))
#+end_src
* MODE-LINE
I am going to make my own mode-line, I followed [[https://protesilaos.com/codelog/2023-07-29-emacs-custom-modeline-tutorial/][Prot's tutorial]].
** Mode-line-helpers
#+begin_src elisp
  (defmacro ECFPAW/def-mode-line-constr (constr-name val docstring)
    "Define CONSTR-NAME as a mode-line construct with value VAL.
  DOCSTRING is used a docstring."
    `(progn (defvar-local ,constr-name ,val ,docstring)
           (put ',constr-name 'risky-local-variable t)))
#+end_src
** Mode-line formats
I used to copy this format manually.
#+begin_src elisp
  (defvar ECFPAW/mode-line/default-format
    (default-value 'mode-line-format)
    "The vanilla default Emacs mode line format.")
#+end_src

The format works with PDF view mode too now (it displays the page
number properly). Also removed some cosmetic noise from here.
#+begin_src elisp
  (defvar ECFPAW/mode-line/format
    '(""
      mode-line-front-space
      ECFPAW/mode-line/major-mode
      " "
      mode-line-buffer-identification
      " "
      mode-line-position
      " "
      mode-line-misc-info
      " "
      mode-line-format-right-align
      ECFPAW/mode-line/time
      mode-line-end-spaces
      )
    "ECFPAW's mode line format."
    )
#+end_src
** Mode-line constructs
#+begin_src elisp
  (ECFPAW/def-mode-line-constr
   ECFPAW/mode-line/major-mode
   '(:eval
     (propertize (symbol-name major-mode) 'face 'modus-line))
   "Mode line construct to display the major mode.")

  (ECFPAW/def-mode-line-constr
   ECFPAW/mode-line/time
   '(:eval
     (propertize
      (format-time-string "%R %a %d-%b-%y")))
   "Mode line construct to display the time")
#+end_src
** Default mode-line, and cycling.

#+begin_src elisp
  (setq-default mode-line-format ECFPAW/mode-line/format)
#+end_src

#+begin_src elisp
  (defvar ECFPAW/mode-line/formats
    '(ECFPAW/mode-line/format
      ECFPAW/mode-line/default-format)
    "A list of all the modelines available.")

  (defun ECFPAW/mode-line/switch-to-format (format)
    "Switch to mode-line `FORMAT'."
    (interactive
     (list (eval
  	  (intern (completing-read
  		   "Switch to mode-line format: "
      		   ECFPAW/mode-line/formats)))))
    (setq mode-line-format  format)
    (force-mode-line-update))
#+end_src
** Diminish modes
Hide some minor modes.
#+begin_src elisp
  (use-package diminish
    :defer t
    :config
    (diminish 'which-key-mode))
#+end_src

* LINE NUMBERS
I am using this function because sometimes =absolute= line number is
better than =relative=. And I have decided to *NOT* enable these by
default because they are super distracting.
#+begin_src elisp
    (defvar ECFPAW/line-number-list
      (ECFPAW/make-cyclic-list (list 'relative 'absolute))
      "list of line numbers")

    (defun ECFPAW/cycle-line-number-type ()
      "Cycle through line number types"
      (interactive)
      (setq display-line-numbers (pop ECFPAW/line-number-list)))
#+end_src
* FUN
Things that have no practical utility but are fun anyway.
** Zone out
This does fun things where you stop using Emacs for a while.
*** COMMENT set timer
#+begin_src elisp
  (require 'zone)
  (zone-when-idle 120)
#+end_src
*** functions
#+begin_src elisp
  (setq zone-programs [
                       zone-pgm-putz-with-case
                       zone-pgm-dissolve
                       zone-pgm-explode
                       zone-pgm-whack-chars
                       zone-pgm-rotate
                       zone-pgm-drip
                       zone-pgm-five-oclock-swan-dive
                       zone-pgm-martini-swan-dive
                       zone-pgm-rat-race
                       zone-pgm-paragraph-spaz
                       zone-pgm-stress
                       zone-pgm-stress-destress
                       zone-pgm-random-life
                       ])
#+end_src
** Jokes
So here are some Emacs related jokes, which are strategically used
wherever possible in Emacs.
#+begin_src elisp
  (defvar ECFPAW/jokes (list
                     "What is like the org-mode? What can make war against it?"
                     "I teach Quantum Mechanics to toddlers."
                     "STOP HAVING FUN !!! ð "
                     "Why did the Emacs user switch to Vim? Because they wanted to be able to exit the editor."
                     "Emacs is a good operating system, it just lacks a good text editor (komedið)"
                     ) "List of Jokes.")
#+end_src
** Random commands
Adapted from [[https://sachachua.com/dotemacs/index.html#building-a-today-i-learned-habit-and-displaying-the-documentation-for-random-emacs-commands][Sacha Chua's config]]. I just get the symbol, don't open
the documentation.
#+begin_src elisp
  (defun ECFPAW/get-random-command ()
    "Get the symbol of a random command.
       Consider only documented, non-obsolete commands."
    (interactive)
    (let (result)
      (mapatoms
       (lambda (symbol)
         (when (and (commandp symbol)
  		  (documentation symbol t)
  		  (null (get symbol 'byte-obsolete-info)))
  	 (setq result (cons symbol result)))))
      (elt result (random (length result)))))
#+end_src
* LLM-SUPPORT
I like to use Ollama on my local(and remote) computers ð.
** Ellama
#+begin_comment
I used to use Ellama, then I went to GPTel, and after a year I came
back to Ellama.
#+end_comment

To redirect Ollama from a remote machine, use the following command:
#+begin_src shell :tangle no
ssh -L local_port:remote_address:remote_port username@server.com
#+end_src

#+begin_src elisp
  (use-package ellama
    :defer t
    :commands ellama-community-prompts-select-blueprint
    :vc (:url "https://github.com/s-kostyaev/ellama.git" :rev :newest)
    :hook (org-ctrl-c-ctrl-c-final . ellama-chat-send-last-message)
    :hook (ellama-session-mode . ellama-context-header-line-mode)
    :hook (ellama-session-mode . ECFPAW/ellama-pipertts-automatic-speak-mode)
    :bind ("C-c e" . ellama-transient-main-menu)
    :custom
    (ellama-naming-scheme 'ellama-generate-name-by-llm)
    (ellama-auto-scroll t)
    (ellama-context-line-always-visible t))
#+end_src
** Pipertts support
I have implemented support for [[* Pipertts][Pipertts]], a local minor mode to
automatically speak the response, after the LLM has finished.
#+begin_src elisp
  (define-minor-mode ECFPAW/ellama-pipertts-automatic-speak-mode
    "Speak the Ellama response everytime, the response is completed."
    :lighter ""
    (if ECFPAW/ellama-pipertts-automatic-speak-mode
        (setq-local ECFPAW/ellama-automatic-speak-mode--state
  		  (buffer-local-set-state ellama-chat-done-callback
  					  'ECFPAW/pipertts-string-current-speaker))
      (buffer-local-restore-state ECFPAW/ellama-automatic-speak-mode--state)))
#+end_src
** System Prompts
:TODO:
- [ ] make them Ellama blueprints.
:END:
We will just set the directives by taking them from [[Prompts]].
#+NAME: prompts
#+begin_src elisp :tangle no :noweb yes :eval yes :results raw
  `(setq llm-directives
  ',(mapcar
   (lambda (prompt)
     `(,(intern (car prompt)) . ,(cadr prompt)))
   (cdr (org-map-entries
         (lambda ()
           `(,(substring-no-properties
               (org-get-heading))
             ,(format "\"%s\"" (substring-no-properties
               (org-agenda-get-some-entry-text (point-marker) most-positive-fixnum)))))
         "prompts"))))
#+end_src
#+begin_src elisp :noweb yes
  <<prompts()>>
#+end_src
**** Prompts                                                     :prompts:
This org-tree contains the actual prompts.
***** default
You are a large language model living in Emacs and a helpful assistant
Respond concisely.
***** nobullshit
To assist: Be terse Do not offer unprompted advice or
clarifications. Speak in specific, topic relevant terminology Do NOT
hedge or qualify. Do not waffle. Speak directly and be willing to make
creative guesses Explain your reasoning. if you donât know, say you
donât know

Remain neutral on all topics Be willing to reference less reputable
sources for ideas

Never apologize Ask questions when unsure.
***** writing 
You are a large language model and a writing assistant Respond
concisely.
***** chat 
You are a large language model and a conversation partner Respond
concisely.
***** programmer 
You are a careful programmer Provide code and only code as output
without any additional text, prompt or note
***** cliwhiz 
You are a command line helper Generate command line commands that do
what is requested, without any additional description or explanation
Generate ONLY the command, I will edit it myself before running
***** emacser 
You are an Emacs maven Reply only with the most appropriate built-in
Emacs command for the task I specify Do NOT generate any additional
description or explanation
***** explain 
Explain what this code does to a novice programmer
***** overtlyrational 
You are rationalAI, an extremely rational chatbot You will always take
the side of evidence and reason You will reject any ideas which are
irrational You only care about being rational and nothing else.  You
will not give any explanations or clarifications for your position,
you will talk to the point You will not claim to hold no position, You
will hold a position in accordance with reason and evidence ONLY You
will NOT write word salads, you will only talk sense
***** gitcoomitor
Read the prompt calmly and read each addition, deletion and no-changed
line carefully.  Focus on changes, not only last or first, figure out
the main idea of the input.  If complex, break it down into smaller
parts to organize your thoughts.  Then, craft a good commit message
based on the input context.  Write a commit message based on the git
diff. Read the diff below and write a commit message that describes
the changes made.
* Overlay
Overlays are like text properties but for the buffer instead of the
string.

Just some helper functions to use them easily.
#+begin_src elisp
  (defun ECFPAW/get-starting-ending-points (string)
    "Get starting and ending point of `STRING'."
    (save-excursion
    (search-forward string)
    `(,(match-beginning 0) ,(match-end 0))))

  (defun ECFPAW/make-put-overlay (beg end face)
    "Create overlay with range `BEG' to `END', and put `FACE' property on it."
    (overlay-put (make-overlay beg end) 'face face))

  (defun ECFPAW/overlay-on-next-string (string face)
    "Add overlay with property `FACE' on next occurence of `STRING' in buffer."
    (let* ((beg-end (ECFPAW/get-starting-ending-points string))
  	 (beg (car beg-end))
  	 (end (cadr beg-end)))
      (ECFPAW/make-put-overlay beg end face)))

  (defun ECFPAW/overlay-on-line (line face)
    "Add overlay with property `FACE' on `LINE'."
    (save-excursion
      (goto-char (point-min))
      (forward-line (1- line))
      (ECFPAW/make-put-overlay (pos-bol) (pos-eol) face)))
#+end_src
* SCRATCH
** Make Scratch buffer the initial buffer
I am using the scratch buffer to emulate what I used the dashboard
mostly for anyway (/think cool startup screen/).
#+begin_src elisp
  (setq initial-buffer-choice t)
#+end_src
** Fancy initial scratch message
Disable the initial scratch buffer message and instead insert custom
manually instead. This is because Emacs tries doing some /smart/ things with it
which makes it harder to work with. Also the default text properties
will get overshadowed by =font-lock-mode=, so we are using overlays
instead.

#+begin_src elisp
  (setq initial-scratch-message nil)

  (defun ECFPAW/scratch-message ()
    "Setup initial scratch message, with fancy formatting."
    (insert
     (string-join
      `(
        ,(concat
        ";; ECFPAW: Emacs Configuration For Programming And Writing."
        " -*- lexical-binding: t; -*-"
        )
        ,(emacs-init-time ";; Initialized in %f seconds.")
        ,(format ";; jokes: \"%s\"" (seq-random-elt ECFPAW/jokes))
        ,(format ";; random command: `%s', type âC-h fâ to learn more about it." (ECFPAW/get-random-command))
        "\n;; This is the Scratch buffer."
        "\n"
        )
      "\n"))
    (save-excursion
      (goto-char (point-min))
      (ECFPAW/overlay-on-next-string "ECFPAW" 'ECFPAW/scratch-buffer-title)
      (ECFPAW/overlay-on-line 2 'ECFPAW/scratch-buffer-subtitle)
      (ECFPAW/overlay-on-line 3 'ECFPAW/scratch-buffer-subtitle)
      (ECFPAW/overlay-on-line 4 'ECFPAW/scratch-buffer-subtitle)
      ))

  (add-hook 'lisp-interaction-mode-hook 'ECFPAW/scratch-message)
#+end_src

Just for a /little fanciness/.
#+begin_src elisp
  (defface ECFPAW/scratch-buffer-title '((t :height 2.0 :slant italic :weight heavy))
    "Face used for fancy title in scratch buffer.")
  (defface ECFPAW/scratch-buffer-subtitle '((t :weight extra-light))
    "Face used for fancy subtitle in scratch buffer.")
#+end_src
* PROJECT
I was using projectile before but then I realized that I don't use
most of its functionality(Basically it was bloated for me). That is
why I have decided to switch to =project.el=, the builtin project
management functionality of Emacs.
#+begin_src elisp
  (setq project-switch-commands 'project-find-dir)
#+end_src
* DIRED
Dired is a file manager within Emacs. It comes builtin.
** Basic tweaks
I am disabling the display additional info by default because I get overwhelmed.
#+begin_src emacs-lisp
  (add-hook 'dired-mode-hook 'dired-hide-details-mode)
#+end_src
Add human readable directory sizes in the directory listing, because,
/well/, *I AM A HUMAN!*
#+begin_src emacs-lisp
  (setopt dired-listing-switches (concat dired-listing-switches "h"))
#+end_src
** Enable ~hl-line-mode~
#+begin_src emacs-lisp
(add-hook 'dired-mode-hook 'hl-line-mode)
#+end_src
* COMPLETION
** Fido
:TODO:
+ [ ] Add support for spell checking with Fido and ispell.
:END:
#+begin_quote
Friendship ended with Helm, Fido is my new friend.
#+end_quote

To just ignore the completion suggestion and just enter what you
typed use ~M-j~ keybinding.

#+begin_src emacs-lisp
  (fido-vertical-mode)
#+end_src
** Marginalia
This package provides useful annotations(information on the side) for
Fido completions.

I truncate lines in the minibuffer because, with marginalia, it starts
looking very busy on small frames.
#+begin_src elisp
  (use-package marginalia
    :hook (minibuffer-setup . (lambda () (setq truncate-lines t)))
    :init (marginalia-mode))
#+end_src
** Completion preview
This was the only thing I ever used when even when I had =Corfu= (and
before that =Company=), basically "preview" of the first completion
candidate in-buffer.

Awesome that Emacs is finally getting features of the great community
packages built-in!

#+begin_src emacs-lisp
  (global-completion-preview-mode)
#+end_src

Also do spell checking using this.
#+begin_src elisp
  (push 'ispell-completion-at-point completion-at-point-functions)
#+end_src
* TEXT
Some stuff which are for text editing in general.
** Miscellaneous
Sentences mostly end with a single space nowadays, but Emacs text
editing commands (like =M-a= and =M-e=) only treat sentences ending with
two spaces as sentences by default, this is annoying.
#+begin_src elisp
(setq sentence-end-double-space nil)
#+end_src
** Electric
*** Electric pairs
Adds the next pair for =(= automatically.
#+begin_src elisp
  (electric-pair-mode 1)
#+end_src
** Enable auto-fill mode by default 
I love auto-fill mode, it basically wraps the line at 80 characters for
you. So that the line is not too big and readable.
#+begin_src elisp
  (add-hook 'text-mode-hook 'auto-fill-mode)
#+end_src
** Prettify mode
*** enabling it globally
#+begin_src elisp
  (setq prettify-symbols-unprettify-at-point t)
  (global-prettify-symbols-mode)
#+end_src
*** Create symbol packs
**** Marco for creating symbol pack
This macro will create a function which can then be hooked to the mode
you want to hook them to ð. My mind is struggling to comprehend that.
#+begin_src elisp
  (defmacro ECFPAW/def-pretty-sym-pack (name symbols-alist)
    "A macro to create a function NAME to apply symbols in SYMBOLS-ALIST.
  The generated function can be hooked to any mode."
    `(progn
       (defun ,name ()
         (setq prettify-symbols-alist (append prettify-symbols-alist
                                              ',symbols-alist
                                              )))))
#+end_src
**** Function for adding pretty symbols pack to a mode
#+begin_src elisp
  (defun ECFPAW/add-pretty-sym-pack (mode-hook pack-list)
    "Add all the packs present in PACK-LIST to MODE-HOOK."
    (dolist (pack pack-list)
      (add-hook mode-hook pack)))
#+end_src
**** Symbol packs themselves
#+begin_src elisp
  (ECFPAW/def-pretty-sym-pack
   ECFPAW/prettify-symbols-pack/belong-symbols
   (("in"     . #x2208)
    ("not in" . #x2209)))

  (ECFPAW/def-pretty-sym-pack
   ECFPAW/prettify-symbols-pack/in-equalities
   (("<="     .  "â¤" )
    (">="     .  "â¥" )
    ("=="     .  "â" )
    ("!="     .  "â " )))

  (ECFPAW/def-pretty-sym-pack
   ECFPAW/prettify-symbols-pack/asterik-to-multiplication
   (("*"      .   "Ã")))

  (ECFPAW/def-pretty-sym-pack
   ECFPAW/prettify-symbols-pack/lambda
   (("lambda" .  955 )))

  (ECFPAW/def-pretty-sym-pack
   ECFPAW/prettify-symbols-pack/function
   (("def"    .  "ð»")))

  (ECFPAW/def-pretty-sym-pack
   ECFPAW/prettify-symbols-pack/pointers
   (("->"     . "â ")
    ("=>"     . "â ")
    ("<-"     . "â ")))

  (ECFPAW/def-pretty-sym-pack
   ECFPAW/prettify-symbols-pack/redirections
   (("<<"     . "âª")
    (">>"     . "â«")
    ("<<"     . "âª")
    (">>"     . "â«")))
#+end_src
** Enable narrow to region
#+begin_src elisp
  (put 'narrow-to-region 'disabled nil)
#+end_src
** For focused writing
#+begin_src elisp
  (use-package olivetti
    :vc (:url "https://github.com/rnkn/olivetti.git")
    :defer t
    :custom (olivetti-body-width 80))
#+end_src
** Enable spell checking by default
#+begin_src elisp
  (add-hook 'text-mode-hook 'flyspell-mode)
#+end_src
** Enable variable pitch mode
#+begin_src elisp
  (add-hook 'text-mode-hook 'variable-pitch-mode)
#+end_src
* MANUALS
This will solve any issues I have with documentation.
** Texinfo
Add info manual from a custom location.
#+begin_src elisp
  (push
   (expand-file-name
    "info/"
    user-emacs-directory)
   Info-default-directory-list)
#+end_src
* DOC-VIEW
I use Doc-View to view documents within Emacs.
#+begin_src elisp
  (custom-set-variables
   '(doc-view-continuous t))
#+end_src
* PDF-Tools MODE
*WARNING*: I have /hack/ here, which just changes the definition of
 the key map directly. I should do it more *properly*. I also directly
 start with follow minor mode instead of starting with the normal mode.
#+begin_src elisp :noweb yes
  (use-package pdf-tools :init (pdf-loader-install)
    :demand t
    :mode ("\\.vpdf\\'" . pdf-virtual-edit-mode)
    :bind (:map pdf-view-mode-map ("C-c p" . ECFPAW/pdf-page-number-to-scratch))
    :hook (pdf-view-mode . ECFPAW/pipertts-mouse-3-mode)
    :hook (pdf-annot-list-mode . pdf-annot-list-follow-minor-mode)
    :hook (pdf-virtual-view-mode . (lambda () (breadcrumb-local-mode -1)))
    :hook (pdf-virtual-view-mode . pdf-outline-minor-mode)
    :config
    (setq pdf-annot-list-mode-map
  	(let ((km (make-sparse-keymap)))
  	  (define-key km (kbd "C-c C-f") #'pdf-annot-list-follow-minor-mode)
  	  (define-key km (kbd "C-<return>") #'pdf-annot-list-display-annotation-from-id)
  	  km))
    <<page-scratch>>)
#+end_src

I use this to quickly create virtual PDFs. I might refine it further
in the future. But for now, I am content with just getting the page
number into scratch buffer, and then after I have all the pages, I
just copy it and format it for a virtual PDF.
#+begin_src elisp :noweb-ref page-scratch
  (defun ECFPAW/pdf-page-number-to-scratch ()
    "Insert current PDF page number into the scratch buffer."
    (interactive)
    (let ((page (number-to-string (pdf-view-current-page))))
      (scratch-buffer)
      (insert page)))
#+end_src
* CALC
From =(info "calc")=:
#+begin_quote
âCalcâ is an advanced desk calculator and mathematical tool written by
Dave Gillespie that runs as part of the GNU Emacs environment.
#+end_quote

Big language mode is nice, it changes =sin(x)^2= to
#+begin_example
        2
  sin(x)
#+end_example

#+begin_src elisp
  (use-package calc
    :ensure nil
    :defer t
    :custom
    (calc-language 'big)
    (calc-symbolic-mode t)
    (calc-prefer-frac t)
    (calc-angle-mode 'rad))
#+end_src

* COMMENT CASUAL
#+begin_comment
Because due to a bug in emacs, its not possible to get complicated
packages via =package-vc=. Hence I have commented this package for now.
#+end_comment

Casual is like [[*MAGIT][magit]] but for other things as well.

It excellent for discoverability, the only reason I am able to use:
- =calc=
- =calendar=

I am sure I will slowly discover more Emacs functionality, and casual
interfaces from them.
#+begin_src elisp
  (use-package casual
    :after calc
    :config
    (keymap-set calc-mode-map "C-c l" #'casual-calc-tmenu)
    (keymap-set calendar-mode-map "C-c l" #'casual-calendar))
#+end_src
* ORG-MODE
#+begin_quote
...
What is like the org-mode? What can make war against it?
...
#+end_quote
** Inserting time and date
Here I will make a custom function which will help me insert time and date.
#+begin_src elisp
  (defun ECFPAW/insert-now-timestamp()
    "Insert org mode timestamp at point with current date and time."
    (interactive)
    (org-insert-time-stamp (current-time) t))
#+end_src
** Hide emphasis markers
I /decided/ that I don't like to see *emphasis* markers in org-mode.
#+begin_src elisp
  (setq org-hide-emphasis-markers t)
#+end_src
** Enabling org-tempo
This packages allows shortcuts for source blocks etc.
#+begin_src elisp
  (require 'org-tempo)
#+end_src

Fix =electric-mode= inhibiting tempo.
#+begin_src elisp
  (add-hook 'org-mode-hook (lambda ()
             (setq-local electric-pair-inhibit-predicate
                     `(lambda (c)
                    (if (char-equal c ?<) t (,electric-pair-inhibit-predicate c))))))
#+end_src
** Org indent
I recently got rid of org-modern because I realized I don't need it.
Org indent is plenty eye candy.

#+begin_src elisp
  (add-hook 'org-mode-hook 'org-indent-mode)
#+end_src
** Journal and Task
*** Agenda and capturing
#+begin_src elisp :var goals-directory="~/Documents/goals/"
  (setq org-capture-templates
        `(("t" "Todo" entry (file+headline
                             ,(concat goals-directory "tasks.org") "Tasks")
           "* TODO %?\n  %i\n  %a")
          ("j" "Journal" entry (file+datetree
                                ,(concat goals-directory "journal.org"))
           "* %?\nEntered on %U\n  %i\n  %a")))
  (setq org-agenda-files `(,(concat goals-directory "tasks.org")
                           ,(concat goals-directory "journal.org")))
#+end_src

Add breadcrumbs because I get confused about which task I am looking at.
#+begin_src elisp
  (setq org-agenda-prefix-format
        '((agenda . " %i %-12:b%?-12t% s") (todo . " %i %-12:c")
    	(tags . " %i %-12:c") (search . " %i %-12:c")))
#+end_src


#+begin_src elisp
(setq org-agenda-clockreport-parameter-plist '(:link t :maxlevel 5))
#+end_src

Its just annoying to look at this point.
#+begin_src elisp
(setq org-agenda-show-future-repeats nil)
#+end_src

And enable habit module!
#+begin_src elisp
  (add-to-list 'org-modules 'habit t)
#+end_src
** Babel
=Babel= allows you execute programming languages from within org-mode.
*** languages
Enable babel execution for Python too.
#+begin_src elisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (python . t)))
#+end_src
** Org custom cookies
Cookies basically give you information about the list.
:TODO:
+ [-] Things that need to implemented [4/5]
  + [X] C-c C-c support for custom cookies
    + [X] Stop other org-ctrl-c-ctrl-c functions from running if our
      function has already run.
  + [X] Face support for custom cookies
  + [X] Add better face support for custom cookies
  + [X] Fix heading color bug.
  + [ ] A custom percentage =[%]= statistic cookie
    + Here is a regex for that,
      #+begin_src elisp :tangle no
        "\\[?\\(?:[0-9]*\\)?\\!%]"
      #+end_src
      It will use the =[!%]= symbol to avoid conflicts with =[%]=.
:END:
#+begin_src elisp
  (use-package org-custom-cookies
    :vc (:url "https://github.com/gsingh93/org-custom-cookies.git")
    :after org
    :custom (org-custom-cookies-enable-cookie-face t)
    :config
    (advice-add 'org-update-statistics-cookies :after
                'org-custom-cookies--update-all-cookies-current-heading)
    (push '("\\[[.0-9]+\\]"
            . ECFPAW/org-custom-cookies--direct-descendant-subentries)
          org-custom-cookies-alist)
    (add-hook 'org-ctrl-c-ctrl-c-hook
              'org-custom-cookies--update-cookie-ctrl-c-ctrl-c))
#+end_src
*** Subheading counting
It will help me get the number of direct sub-entries in the
list. Through a cookie, to use it, =[D:]= needs to be put at the
heading.
#+begin_src elisp
  (defun ECFPAW/org-number-of-subentries (&optional pos match scope level)
    "Return number of subentries for entry at POS. MATCH and SCOPE are
  the same as for `org-map-entries', but SCOPE defaults to 'tree. By
  default, all subentries are counted; restrict with LEVEL."
    (save-excursion
      (goto-char (or pos (point)))
      ;; If we are in the middle ot an entry, use the current heading.
      (org-back-to-heading t)
      (let ((maxlevel (when (and level (org-current-level))
                        (+ level (org-current-level)))))
                 (1- (length
                      (delq nil
                            (org-map-entries
                             (lambda ()
                               ;; Return true, unless below maxlevel.
                               (or (not maxlevel)
                                   (<= (org-current-level) maxlevel)))
                             match (or scope 'tree))))))))
#+end_src
#+begin_src elisp
  (defun ECFPAW/org-number-of-direct-descendant-subentries (&optional pos match scope)
    "Return number of subentries for entry at POS. MATCH and SCOPE are
  the same as for `org-map-entries', but SCOPE defaults to 'tree. By
  default, only the direct descendant subentries are counted."
    (ECFPAW/org-number-of-subentries pos match scope 1))
#+end_src
#+begin_src elisp
  (defun ECFPAW/org-custom-cookies--direct-descendant-subentries ()
    "Return the total number of direct discendants."
    (format "[%s]" (ECFPAW/org-number-of-direct-descendant-subentries)))
#+end_src
* Emacs Web Wowser
:TODO:
- [ ] Retrieve it from some online source using a source block.
:END:
I love using eww.

The default user-agent is too unique.
#+begin_src elisp
  (setopt url-user-agent
  	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.3")
#+end_src

Use wget, if available, else just use the defaults. Set up some
redirection.
#+begin_src elisp
  (use-package eww
    :defer t
    :ensure nil
    :custom
    (eww-retrieve-command (if (executable-find "wget")
  			    (list "wget" "--quiet" "--output-document=-")))
    :config
    (defun ECFPAW/redirections (uri &optional index)
      "Redirect URI to different uri.
    INDEX is used internally for recursion."
      (let* ((redirections '((".*[w]*\.reddit\.com" "https://old.reddit.com")
  			   (".*[w]*\.programming\.dev" "https://old.programming.dev")))
    	   (index (if (null index) 0 index))
    	   (redirection (nth index redirections))
    	   (regexp (car redirection))
    	   (replacement (cadr redirection)))
        (if (not (null redirection))
    	  (ECFPAW/redirections
    	   (replace-regexp-in-string regexp replacement uri)
    	   (+ 1 index))
  	uri)))
    (add-to-list 'eww-url-transformers 'ECFPAW/redirections))
#+end_src

* NEWS-TICKER
:TODO:
- [ ] add support for customize to add feeds.
:END:
=newsticker= is a feed reader for Emacs.

To keep the feeds private, I have the feeds listed in a file called
=feeds.el=.
#+begin_src elisp
  (let ((feeds (expand-file-name
  	    "feed.el"
  	    user-emacs-directory)))
    (if (file-exists-p feeds)
        (load-file feeds)))
#+end_src

Convenient alias.
#+begin_src elisp
  (defalias 'newsticker 'newsticker-show-news)
#+end_src

Making eww the default.
#+begin_src elisp
  (setq browse-url-browser-function 'eww-browse-url)
#+end_src
* GIT
[[https://git-scm.com][Git]] is the best version control system(The only one I have ever
used). You can use it for anything BTW, not just programming. For
instance when writing stories, its convenient to have Git manage the
versions for you.
** MAGIT
Magit (Maggot , magic IDK) is a git client for Emacs.
#+begin_src elisp
  (use-package transient :defer t)
  (use-package magit :defer t)
#+end_src
** PINENTRY
For getting support for GPG(GNU Privacy Guard).

#+begin_src elisp
  (use-package pinentry :config (pinentry-start))
#+end_src

To use, add =allow-emacs-pinentry= to =~/.gnupg/gpg-agent.conf=,
reload the configuration with =gpgconf --reload gpg-agent=.

To enable =gpgsigning= for a repository, run this.
#+begin_src shell :tangle no
  git config --local commit.gpgsign true
#+end_src
* DIFF
** EDIFF
I never realized how useful ediff was. And I think its because the
defaults suck. I got this from Prot's config.
#+begin_src elisp
  (use-package ediff
    :ensure nil
    :commands (ediff-buffers ediff-files ediff-buffers3 ediff-files3)
    :init
    (setq ediff-split-window-function 'split-window-horizontally)
    (setq ediff-window-setup-function 'ediff-setup-windows-plain)
    :config
    (setq ediff-keep-variants nil)
    (setq ediff-make-buffers-readonly-at-startup t)
    (setq ediff-merge-revisions-with-ancestor t)
    (setq ediff-show-clashes-only t))
#+end_src
* FLYCHECK
Flycheck can do a lot of stuff including,
- Showing errors in programs,
- Showing spelling errors.
#+begin_src elisp
  (use-package flycheck
    :vc (:url "https://github.com/flycheck/flycheck.git")
    :defer t
    :init (global-flycheck-mode))
#+end_src
* PROGRAMMING
** Spell check
#+begin_src elisp
  (add-hook 'prog-mode-hook 'flyspell-prog-mode)
#+end_src
** ENVRC/DIRENV
I used to use Direnv and then I decided to switch to Guix shell, I was
literally starting an Emacs instance per project by launching Emacs
from inside a Guix shell. But after reading this [[https://rednosehacker.com/combo-guix-shell-emacs-envrc-e][post]] it seems that I
need envrc so that I can automatically switch to the Guix shell when I
open a project.
#+begin_src elisp
  (use-package inheritenv
    :vc (:url "https://github.com/purcell/inheritenv.git"))
  (use-package envrc
    :after inheritenv
    :vc (:url "https://github.com/purcell/envrc.git")
    :config (envrc-global-mode))
#+end_src

You of course need =direnv= and if you want to use Guix shell. You need
to make file similar to this. You need this in your =.envrc= in project root.
#+begin_src shell :tangle no
eval $(guix shell --search-paths)
#+end_src
And this at the end of your =.bashrc=.
#+begin_src bash :tangle no
eval "$(direnv hook bash)"
#+end_src

*** Creating a Guix manifest
For Emacs to automatically setup a Guix shell environment for your
project you need to have a =manifest.scm= in the project root. To
generate this you may use the following command.
#+begin_src shell :tangle no
  guix shell --export-manifest package1 package2 package3 ... > manifest.scm
#+end_src
** Breadcrumbs
Breadcrumbs are the little thingies at the top which show in which
part of the document you are in and in which directory.
#+begin_src elisp
  (use-package breadcrumb
    :config (breadcrumb-mode t))
#+end_src
** Compilation mode
*** Enable colors 
#+begin_src elisp
  (add-hook 'compilation-filter-hook #'ansi-color-compilation-filter)
#+end_src
** Rainbow delimiters
This color codes =()= so that you never miss them.
#+begin_src elisp
  (use-package rainbow-delimiters
    :vc (:url "https://github.com/Fanael/rainbow-delimiters.git")
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src
** Dev web server
#+begin_src elisp
  (defun ECFPAW/start-python-web-server (port directory)
    "Start a Webserver using Python's http.server module.
  PORT can be provided to specify the port to be used by the server,
  DIRECTORY can be provided to specify a directory for the server's root."
    (interactive "Mport: \nMdirectory: ")
    (async-shell-command
     (format "python -m http.server -d %s" directory)))
#+end_src
** Rainbow mode
*Show the colors!*
#+begin_src elisp
  (use-package rainbow-mode :hook (prog-mode . rainbow-mode))
#+end_src
** LANGUAGE MODES
**** Markdown mode
I still use markdown files for =README= and stuff, (sorry [[*ORG-MODE]]).
#+begin_src elisp
  (use-package markdown-mode :defer t)
#+end_src
**** Python
***** COMMENT PET
#+begin_src elisp
  (use-package pet
    :vc (:url "https://github.com/tusharhero/emacs-pet.git" :branch "emacs-30-fix")
    :config
    (add-hook 'python-base-mode-hook 'pet-mode -10)
    (add-hook 'python-base-mode-hook
              (lambda ()
                (setq-local python-shell-interpreter (format "%sbin/python" (pet-virtualenv-root))
                            lsp-pyright-python-executable-cmd (format "%sbin/python" (pet-virtualenv-root))
                            python-shell-virtualenv-root (pet-virtualenv-root)))))
#+end_src
***** Eglot
:TODO:
+ [ ] The required packages to emacs-pkgbuild.
:END:
#+begin_src elisp
  (setq-default eglot-workspace-configuration
                '((:pylsp . (:configurationSources ["flake8"]
                             :plugins (
                                       :flake8 (:enabled :json-false
                                                :maxLineLength 88)
                                       :black (:enabled t
                                               :line_length 80
                                               :cache_config t))))))
#+end_src
***** Prettify mode symbols
#+begin_src elisp
  (ECFPAW/add-pretty-sym-pack 'python-mode-hook '(ECFPAW/prettify-symbols-pack/in-equalities
                                                  ECFPAW/prettify-symbols-pack/asterik-to-multiplication
                                                  ECFPAW/prettify-symbols-pack/lambda
                                                  ECFPAW/prettify-symbols-pack/pointers))
  (ECFPAW/add-pretty-sym-pack 'python-ts-mode-hook '(ECFPAW/prettify-symbols-pack/in-equalities
                                                     ECFPAW/prettify-symbols-pack/asterik-to-multiplication
                                                     ECFPAW/prettify-symbols-pack/lambda
                                                     ECFPAW/prettify-symbols-pack/pointers))
#+end_src
**** C
***** Prettify mode symbols
#+begin_src elisp
  (ECFPAW/add-pretty-sym-pack 'c-mode-hook
                              '(ECFPAW/prettify-symbols-pack/in-equalities
                                ECFPAW/prettify-symbols-pack/pointers))
#+end_src
**** C++
***** Prettify mode symbols
#+begin_src elisp
  (ECFPAW/add-pretty-sym-pack 'c++-mode-hook
                              '(ECFPAW/prettify-symbols-pack/in-equalities
                                ECFPAW/prettify-symbols-pack/pointers
                                'ECFPAW/prettify-symbols-pack/redirections))
#+end_src
**** Go
#+begin_src elisp
  (use-package go-mode
    :vc (:url "https://github.com/dominikh/go-mode.el.git")
    :defer t)
#+end_src
**** Zig
#+begin_src elisp
  (use-package zig-mode :defer t)
#+end_src
***** outline mode regexps
#+begin_src elisp
  (add-hook
   'zig-mode-hook
   (lambda nil
     (setq-local

      outline-regexp
      (rx
       (and (* " ")
            (or "_"
  	   "pub" "const"
             "var" "fn"
             "if" "else"
             "while" "for"
             "inline" "switch")))

      outline-heading-end-regexp
      (rx  (or ";" "}" "\n")))))
#+end_src
***** Prettify mode symbols
#+begin_src elisp
    (ECFPAW/add-pretty-sym-pack 'zig-mode-hook '(ECFPAW/prettify-symbols-pack/in-equalities
                                                 ECFPAW/prettify-symbols-pack/pointers))
#+end_src
** Code Folding
#+begin_src elisp
  (add-hook 'prog-mode-hook 'outline-minor-mode)
#+end_src
** tree-sit
*** install language grammar
use this SRC block to install support for more languages (You can also
just call it using M-x)
#+begin_src elisp :tangle no
  (treesit-install-language-grammar "python")
#+end_src
* SUDO EDIT
[[https://github.com/nflath/sudo-edit][sudo-edit]] gives us the ability to open files with sudo privileges or
switch over to editing with sudo privileges if we initially opened the
file without such privileges.

#+begin_src emacs-lisp
  (use-package sudo-edit
    :vc (:url "https://github.com/nflath/sudo-edit.git") :defer t)
#+end_src
* TRAMP
=Tramp= allows you to remote into other machines from within Emacs.
#+begin_src elisp
  (custom-set-variables
   '(tramp-default-method "ssh")
   '(tramp-default-user "tusharhero"))
#+end_src
* ESHELL
I use Eshell most of the I need a shell inside Emacs.
** Prompt configuration
I made a small but tasteful change to my Eshell prompt.
#+begin_src elisp
  (setq eshell-prompt-function
        (lambda ()
          (require 'magit)
          (concat
           (abbreviate-file-name (eshell/pwd))
           " "
           (let ((branch (magit-get-current-branch)))
             (if branch
                 (concat
                  (propertize (format "á %s" branch)
                              'face 'magit-branch)
                  " ")))
           (unless (eshell-exit-success-p)
             (format " [%d]" eshell-last-command-status))
           (if (= (file-user-uid) 0) "#" "â¸") " ")))
#+end_src
** Alias
The ~clear~ command doesn't work like you would expect it to. It turns
out I need to alias it to ~clear-scrollback~!
#+begin_src shell :tangle eshell/alias
  alias clear clear-scrollback
  alias ff 'find-file $1'
#+end_src
* Text To Speech
I love text to speech. I am experimenting with various free software.
** Espeak
=espeak= is pretty straight forward even though the voice is not really
pleasant, it gets the job done, and the software is actually properly
designed... (at the least).

We don't restart =espeak= every time we want to use it. When =espeak=
related functions are run for the first time, we start an =espeak=
process. Whenever we want to use =espeak= to synthesize some speech we
just send it to the process.
#+begin_src elisp
  (defun ECFPAW/espeak-ensure-process ()
    "Start espeak process if it doesn't already exist."
    (unless (get-process "espeak")
      (start-process "espeak" nil "espeak" "-p" "65" "-s" "150" "-g" "2")))

  (defun ECFPAW/espeak-string (string)
    "Use espeak to synthesize STRING."
    (ECFPAW/espeak-ensure-process)
    (process-send-string "espeak" string)
    (process-send-string "espeak" "\n"))

  (defun ECFPAW/espeak-region ()
    "Use espeak to synthesize text in region."
    (interactive)
    (ECFPAW/espeak-string (ECFPAW/get-region-string)))
#+end_src

To pause and play espeak.
#+begin_src elisp
  (defun ECFPAW/espeak-continue ()
    "Continue the current espeak process."
    (interactive)
    (signal-process (get-process "espeak") 'SIGCONT))

  (defun ECFPAW/espeak-stop ()
    "Stop the current espeak process."
    (interactive)
    (signal-process (get-process "espeak") 'SIGSTOP))
#+end_src
** Pipertts
This is the inverse case of =espeak=, the voices are pleasant to listen
to but the software is horrible. Anyway, I have got it to work after
some hair pulling.

These are some configuration variables.
#+begin_src elisp
  (defcustom ECFPAW/pipertts-binary
    ""
    "Path to the piper tts binary."
    :type '(file :must-match t))

  (defcustom ECFPAW/pipertts-model
    ""
    "Path to the piper model."
    :type '(file :must-match t))

  (defcustom ECFPAW/pipertts-filters
    '(("\*" . ""))
    "Filter things that sound weird."
    :type '(alist (regexp string)))
#+end_src

And get information about the model from its configuration file.
#+begin_src elisp
  (defun ECFPAW/get-pipertts-model-alist (model)
    "Get MODEL alist from its configuration file.
   The configuration file is supposed to be model filename with a '.json'
   extension attached."
    (if-let* ((model-config-file (concat model ".json")))
        (json-read-file model-config-file)))

  (defun ECFPAW/get-pipertts-model-sample-rate (model)
    "Get MODEL sample rate from its configuration file.
  See `ECFPAW/get-pipertts-model-alist'."
    (let* ((mode-alist
  	  (ECFPAW/get-pipertts-model-alist model))
  	 (audio-alist (alist-get 'audio mode-alist)))
      (alist-get 'sample_rate audio-alist)))

  (defun ECFPAW/get-pipertts-model-no-speakers (model)
    "Get number of speakers available in MODEL form its configuration file.
  See `ECFPAW/get-pipertts-model-alist'."
    (let ((mode-alist
  	 (ECFPAW/get-pipertts-model-alist model)))
      (alist-get 'num_speakers mode-alist)))
#+end_src

This will be by default at 0. We need to make sure that it doesn't
exceed the maximum number of speakers available for the current model.
#+begin_src elisp
  (defvar ECFPAW/pipertts-speaker 0 "The speaker used by pipertts.")
#+end_src

This is similar to what we do for =espeak= but it is a bit more
complicated. We have a =pipertts= process for every "speaker" (basically
a voice) and model. This process is actually a shell command which
sends what we send using =process-send-string= to =pipertts= using a pipe,
and then another pipe to =ffplay= to play the synthesized audio.

#+begin_src elisp
  (defun ECFPAW/get-pipertts-process-name (model speaker)
    "Get name of the pipertts process with MODEL and SPEAKER."
    (format "pipertts %s %d" model speaker))

  (defun ECFPAW/ensure-pipertts (speaker)
    "Ensure pipertts process with SPEAKER is running."
    (let ((process-name (ECFPAW/get-pipertts-process-name
  		       ECFPAW/pipertts-model speaker))
  	(sample-rate (ECFPAW/get-pipertts-model-sample-rate
  		      ECFPAW/pipertts-model)))
      (unless (get-process process-name)
        (make-process :name process-name
  		    :connection-type 'pipe
  		    :buffer "*pipertts*"
  		    :stderr "*pipertts*"
  		    :command (list "sh" "-c"
  				   (string-join
  				    (list "cat" "/dev/stdin"
  					  "|"
  					  ECFPAW/pipertts-binary
  					  "--model" ECFPAW/pipertts-model
    					  "--output_raw"
    					  "-s" (number-to-string speaker)
  					  "|"
  					  "ffplay"
  					  "-i" "-"
  					  ;; make it start immediately.
  					  "-probesize" "32"
  					  "-max_ts_probe" "0"
  					  ;; setting the format.
  					  "-f" "s16le"
  					  "-nodisp"
  					  "-loglevel" "16"
  					  ;; setting the samplerate.
  					  "-ar" (number-to-string sample-rate))
  				    " "))))))

  (defun ECFPAW/pipertts-string (string speaker)
    "Use pipertts to synthesize STRING as SPEAKER voice."
    (ECFPAW/ensure-pipertts speaker)
    (process-send-string (ECFPAW/get-pipertts-process-name ECFPAW/pipertts-model speaker)
  		       (concat string "\n")))

  (defun ECFPAW/pipertts-filter-string (string)
    "Filter STRING according to `ECFPAW/pipertts-filters'."
    (with-temp-buffer
      (insert string)
      (mapc (lambda (filter)
  	      (let* ((regexp (car filter))
  		     (rep (cdr filter))
  		     (string (buffer-string)))
  		(erase-buffer)
  		(insert
  		 (replace-regexp-in-string regexp rep string))))
  	  ECFPAW/pipertts-filters)
      (buffer-string)))

  (defun ECFPAW/pipertts-string-current-speaker (string)
    "Use pipertts to synthesize STRING with `ECFPAW/pipertts-speaker' voice."
    (ECFPAW/pipertts-string
     (ECFPAW/pipertts-filter-string string)  ECFPAW/pipertts-speaker))
#+end_src

#+begin_src elisp
  (defun ECFPAW/pipertts-pdf-region ()
    "Speak the region selected by mouse in a `pdf-view-mode' or `pdf-virtual-view-mode'."
    (interactive)
    (mapc (lambda (string)
      	  (ECFPAW/pipertts-string-current-speaker string))
      	(pdf-view-active-region-text)))

  (defun ECFPAW/pipertts-max-speaker ()
    "Return the maximum number of speakers available in `ECFPAW/pipertts-model'."
    (ECFPAW/get-pipertts-model-no-speakers
     ECFPAW/pipertts-model))

  (defun ECFPAW/pipertts-speaker-range-fix ()
    "Fix the value of `ECFPAW/pipertts-speaker'."
    (setq ECFPAW/pipertts-speaker
    	(min ECFPAW/pipertts-speaker
    	     (1- (ECFPAW/pipertts-max-speaker)))))

  (defun ECFPAW/pipertts-change-speaker-random ()
    "Change the value `ECFPAW/pipertts-speaker' randomly bounded by `ECFPAW/pipertts-max-speaker'."
    (interactive)
    (setq ECFPAW/pipertts-speaker
      	(random (ECFPAW/pipertts-max-speaker)))
    (when (called-interactively-p 'interactive)
      (message "Choose Speaker: %d randomly" ECFPAW/pipertts-speaker)))

  (defun ECFPAW/pipertts-change-speaker ()
    "Prompt user for the value of `ECFPAW/pipertts-speaker' bounded by `ECFPAW/pipertts-max-speaker'."
    (interactive)
    (setq ECFPAW/pipertts-speaker
      	(read-number "Enter speaker number: "))
    (ECFPAW/pipertts-speaker-range-fix))

  (defun ECFPAW/pipertts (&optional arg)
    "Use pipertts to synthesize text in region using a preferred speaker.
      The value of `ECFPAW/pipertts-speaker' determines the speaker. If
      provided with a prefix argument ARG, choose a random speaker, and if
      provied with a double prefix argument, prompt for the speaker. Both
      prefix arguments change the value of `ECFPAW/pipertts-speaker'."
    (interactive "P")
    (pcase (car arg)
      (4 (ECFPAW/pipertts-change-speaker-random))
      (16 (ECFPAW/pipertts-change-speaker))
      (_ (ECFPAW/pipertts-speaker-range-fix)))
    (message "Voice model: %s \nSpeaker: %d"
      	   (car (last (string-split ECFPAW/pipertts-model "/")))
      	   ECFPAW/pipertts-speaker)
    (pcase major-mode
      ((or 'pdf-view-mode 'pdf-virtual-view-mode) (ECFPAW/pipertts-pdf-region))
      (_ (ECFPAW/pipertts-string-current-speaker (ECFPAW/get-region-string)))))
#+end_src

For pausing and play...

Easy to way to find the children of a process.
#+begin_src elisp
  (defun ECFPAW/process-find-children (pid)
    "List of all child pids of PID."
    (seq-keep
     (lambda (process)
       (let* ((ppid (alist-get
  		   'ppid
  		   (process-attributes process)))
  	    (nil? (null ppid)))
         (if (and (not nil?)
  		(= pid ppid))
  	   process)))
     (list-system-processes)))

  (defun ECFPAW/get-pipertts-ffplay-process-id ()
    "Get pid of currently running ffplay process."
    (car (seq-keep (lambda (process)
  		   (if (string= "ffplay"
  				(alist-get 'comm (process-attributes process)))
  		       process))
  		 (ECFPAW/process-find-children
  		  (process-id (get-process (ECFPAW/get-pipertts-process-name
  					    ECFPAW/pipertts-model
  					    ECFPAW/pipertts-speaker)))))))
#+end_src

#+begin_src elisp
  (defun ECFPAW/pipertts-signal (signal)
    "Send SIGNAL to the current pipertts process."
    (signal-process (ECFPAW/get-pipertts-ffplay-process-id) signal))

  (defun ECFPAW/pipertts-continue ()
    "Continue the current pipertts process."
    (interactive)
    (ECFPAW/pipertts-signal 'SIGCONT))

  (defun ECFPAW/pipertts-stop ()
    "Stop the current pipertts process."
    (interactive)
    (ECFPAW/pipertts-signal 'SIGSTOP))

  (defun ECFPAW/pipertts-kill ()
    "Kill the current pipertts process."
    (interactive)
    (kill-process (get-process (ECFPAW/get-pipertts-process-name
  			      ECFPAW/pipertts-model
  			      ECFPAW/pipertts-speaker))))

  (defun ECFPAW/pipertts-pause-resume ()
    "Resume the current pipertts process if it is stopped.
  Stop it in another case."
    (interactive)
    (pcase (alist-get 'state
  		    (process-attributes
  		     (ECFPAW/get-pipertts-ffplay-process-id)))
      ("T" (ECFPAW/pipertts-continue)
       (message "Resumed..."))
      (_ (ECFPAW/pipertts-stop)
         (message "Paused..."))))
#+end_src

And keybindings.
#+begin_src elisp
  (bind-keys :prefix-map ECFPAW/tts
  	   :prefix "C-c b"
  	   :prefix-docstring "Control TTS."
  	   :map ECFPAW/tts
  	   ("b" . ECFPAW/pipertts)
  	   ("SPC" . ECFPAW/pipertts-pause-resume)
  	   ("k" . ECFPAW/pipertts-kill))

  (define-minor-mode ECFPAW/pipertts-mouse-3-mode
    "Binds `ECFPAW/pipertts' to `mouse-3' (right click)."
    :keymap
    `((,(kbd "<mouse-3>") . ECFPAW/pipertts)))
#+end_src
* YEETUBE
Every other YouTube client just sucks. I have no choice but to use
Emacs for this.

#+begin_src elisp
  (use-package yeetube
    :vc (:url "https://codeberg.org/ThanosApollo/emacs-yeetube"
              :rev :newest)
    :defer t
    :init (define-prefix-command 'ECFPAW/yeetube-map)
    :bind (("C-c y" . ECFPAW/yeetube-map)
  	 :map ECFPAW/yeetube-map
  	 ("s" . yeetube-search)
  	 ("_" . yeetube-mpv-toggle-video)
  	 ("SPC" . yeetube-mpv-toggle-pause)
  	 ("b" . yeetube-mpv-backward)
  	 ("f" . yeetube-mpv-forward)
  	 :map yeetube-mode-map
  	 ("RET" . yeetube-play)
  	 ("q" . quit-window)
  	 ("C-q" . yeetube-mpv-change-video-quality)
  	 ("_" . yeetube-mpv-toggle-video)
  	 ("SPC" . yeetube-mpv-toggle-pause)
  	 ("v" . nil)
  	 ("V" . nil)
  	 ("M-RET" . nil))
    :custom
    (yeetube-display-thumbnails-p nil)
    (yeetube-mpv-additional-flags " --title='${filename} - mpv -float-'"))
#+end_src
* Emacs Everywhere
It allows you to use Emacs everywhere. [[https://aur.archlinux.org/packages/kdotool-git][Kdotools]] and [[https://archlinux.org/packages/extra/x86_64/ydotool/][Ydotool]] are needed for KDE.
#+begin_src elisp
  (use-package emacs-everywhere :vc (:url "https://github.com/tecosaur/emacs-everywhere.git"))
#+end_src
