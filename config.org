#+TITLE: Emacs Config For Programming And Writing (ECFPAW)
#+AUTHOR: tusharhero
#+EMAIL: tusharhero@sdf.org
#+DESCRIPTION: It actually does more than just programming and writing.
#+STARTUP: overview
* LICENSE NOTICE
  :PROPERTIES:
  :VISIBILITY: folded
  :END:
#+begin_src elisp
;; The GPLv3 License (GPLv3)

;; Copyright ¬© 2023 Tushar Maharana

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.
#+end_src
* IMPORTANT PROGRAMS TO LOAD FIRST
** Package Manager
I am going to use [[https://github.com/progfolio/elpaca][Elapaca]] package manager.
#+BEGIN_SRC elisp
(defvar elpaca-installer-version 0.5)
(defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
(defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
(defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
(defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
			:ref nil
			:files (:defaults (:exclude "extensions"))
			:build (:not elpaca--activate-package)))
(let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
 (build (expand-file-name "elpaca/" elpaca-builds-directory))
 (order (cdr elpaca-order))
 (default-directory repo))
  (add-to-list 'load-path (if (file-exists-p build) build repo))
  (unless (file-exists-p repo)
    (make-directory repo t)
    (when (< emacs-major-version 28) (require 'subr-x))
    (condition-case-unless-debug err
  (if-let ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
	   ((zerop (call-process "git" nil buffer t "clone"
				 (plist-get order :repo) repo)))
	   ((zerop (call-process "git" nil buffer t "checkout"
				 (or (plist-get order :ref) "--"))))
	   (emacs (concat invocation-directory invocation-name))
	   ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
				 "--eval" "(byte-recompile-directory \".\" 0 'force)")))
	   ((require 'elpaca))
	   ((elpaca-generate-autoloads "elpaca" repo)))
      (kill-buffer buffer)
    (error "%s" (with-current-buffer buffer (buffer-string))))
((error) (warn "%s" err) (delete-directory repo 'recursive))))
  (unless (require 'elpaca-autoloads nil t)
    (require 'elpaca)
    (elpaca-generate-autoloads "elpaca" repo)
    (load "./elpaca-autoloads")))
(add-hook 'after-init-hook #'elpaca-process-queues)
(elpaca `(,@elpaca-order))
#+END_SRC
***  use-package support.
[[https://jwiegley.github.io/use-package/][use-package]] is useful for configuring and installing packages.
#+begin_src elisp
  ;; Install use-package support
  (elpaca elpaca-use-package
    ;; Enable :elpaca use-package keyword.
    (elpaca-use-package-mode)
    ;; Assume :elpaca t unless otherwise specified.
    (setq elpaca-use-package-by-default t))
  ;; Block until current queue processed.
  (elpaca-wait)
#+end_src
* SET LOCALE
This is will fix text glitches in vterm(see [[*SHELLS AND TERMINALS]]).
#+begin_src elisp
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+end_src
* Load Evil Mode
Getting evil mode installed because, I was Vim user and I am most
comfortable in those keybindings.
#+begin_src elisp
  (setq evil-want-C-u-scroll t) ;; fix C-u scrolling
  (setq evil-undo-system 'undo-redo) ;; fix undo redo system
  (use-package evil
    :init ;; tweak evil's configuration before loading it.
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    (setq evil-vsplit-window-right t)
    (setq evil-split-window-below t)
    (evil-mode))
  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))
  (use-package evil-tutor)
  (use-package evil-numbers :after evil)
#+end_src

* GENERAL KEYBINDINGS
I will use general package to create all the keybindings for ECFPAW. I
only make key binds for the stuff I really need(That goes for the
configuration in general as well).
#+begin_src elisp
  (use-package general
    :config
    (general-evil-setup)

    ;; set up ',' as major mode keybinds key
    (evil-define-key 'normal global-map (kbd ",") 'ECFPAW/major-mode-keybinds)

    ;; set up 'SPC' as the global leader key
    (general-create-definer ECFPAW/leader-keys
      :states '(normal insert visual emacs)
      :keymaps 'override
      :prefix "SPC" ;; set leader
      :global-prefix "M-SPC") ;; access leader in insert mode

    ;; direct convinient keybindings
    (ECFPAW/leader-keys
      "SPC" '(helm-M-x :wk "Execute command")
      "TAB" '(mode-line-other-buffer :wk "Last buffer")
      "c" '(comment-line :wk "Comment lines")
      "'" '(vterm-toggle :wk "Toggle vterm")
      "a" '(evil-numbers/inc-at-pt :wk "Increment number")
      "A" '(evil-numbers/dec-at-pt :wk "Decrement number")
      "g" '(magit :wk "Magit"))

    ;; file related keybindings
    (ECFPAW/leader-keys
      "f" '(:ignore t :wk "files")
      "f f" '(helm-find-files :wk "Find file")
      "f c" '((lambda () (interactive) (find-file (locate-user-emacs-file "config.org"))) :wk "Edit emacs config")
      "f r" '(recentf :wk "Find recent files")
      "f e r" '((lambda () (interactive) (load-file (locate-user-emacs-file "init.el")) (ignore (elpaca-process-queues)))
                :wk "Reload emacs config"))

    ;; insert related keybindings
    (ECFPAW/leader-keys
      "i" '(:ignore t :wk "insert")
      "i e" '(emoji-insert :wk "insert emoji"))

    ;; dired related keybindings
    (ECFPAW/leader-keys
      "d" '(:ignore t :wk "Dired")
      "d d" '(dired :wk "Open dired")
      "d j" '(dired-jump :wk "Dired jump to current"))

    ;; buffer related keybindings
    (ECFPAW/leader-keys
      "b" '(:ignore t :wk "buffer")
      "b b" '(helm-mini :wk "Switch buffer")
      "b i" '(ibuffer :wk "Ibuffer")
      "b d" '(kill-this-buffer :wk "Kill this buffer")
      "b x" '(kill-this-buffer :wk "Kill this buffer")
      "b n" '(next-buffer :wk "Next buffer")
      "b p" '(previous-buffer :wk "Previous buffer")
      "b r" '(revert-buffer :wk "Revert buffer")
      "b h" '((lambda () (interactive) (switch-to-buffer "*dashboard*")) :wk "dashboard buffer")
      "b s" '((lambda () (interactive) (switch-to-buffer "*scratch*")) :wk "scratch buffer"))

    ;; bookmark related keybindings
    (ECFPAW/leader-keys
      "B" '(:ignore t :wk "bookmark")
      "B s" '(bookmark-set :wk "bookmark set")
      "B l" '(bookmark-bmenu-list :wk "bookmark list"))

    ;; eval related keybindings
    (ECFPAW/leader-keys
      "e" '(:ignore t :wk "Evaluate")    
      "e b" '(eval-buffer :wk "Evaluate elisp in buffer")
      "e d" '(eval-defun :wk "Evaluate defun containing or after point")
      "e e" '(eval-expression :wk "Evaluate and elisp expression")
      "e l" '(eval-last-sexp :wk "Evaluate elisp expression before point")
      "e r" '(eval-region :wk "Evaluate elisp in region"))

    ;; help keybindings
    (ECFPAW/leader-keys
      "h" '(:ignore t :wk "Help")
      "h h" '(help :wk "Help Help!")
      "h f" '(describe-function :wk "Describe function")
      "h v" '(describe-variable :wk "Describe variable")
      "h m" '(:ignore t :wk "Manuals")
      "h m E" '(info-emacs-manual :wk "Emacs manual")
      "h m e" '(helm-info-eglot :wk "Eglot manual"))

    ;; toggle keybindings
    (ECFPAW/leader-keys
      "t" '(:ignore t :wk "Toggle")
      "t l" '(display-line-numbers-mode :wk "Toggle line numbers")
      "t L" '(ECFPAW/cycle-line-number-type :wk "cycle line number types")
      "t s" '(flyspell-mode :wk "Toggle flyspell(spellchecking)")
      "t t" '(visual-line-mode :wk "Toggle truncated lines")
      "t c" '(outline-minor-mode :wk "enable code-folding")
      "t o" '(org-mode :wk "toggle org-mode")
      "t p" '(peep-dired :wk "Peep-dired")
      "t T" '(ECFPAW/cycle-my-theme :wk "Cycle through my themes")
      )

    ;; spelling keybindings
    (ECFPAW/leader-keys
      "S" '(:ignore t :wk "Spelling")
      "S s" '(helm-flyspell-correct :wk "correct the word")
      "S t" '(flyspell-mode :wk "Toggle flyspell(spellchecking)"))

    ;; org-mode keybindings
    (ECFPAW/leader-keys
      "o" '(:ignore t :wk "org-mode")
      "o o" '(org-mode :wk "toggle org-mode")
      "o r" '(:ignore t :wk "org-roam")
      "o p" '(org-toggle-latex-fragment :wk "toggle latex preview")
      "o j" '(org-ctrl-c-ctrl-c :wk "toggle item")
      "o i" '(:ignore :wk "insert")
      "o i d" '(ECFPAW/insert-now-timestamp :wk "time stamp"))
    (evil-define-key 'normal org-mode-map (kbd "SPC o b") org-babel-map)
    (which-key-add-key-based-replacements "SPC o b" "babel")

    ;; org-roam keybindings
    (ECFPAW/leader-keys
      "o r l" '(org-roam-buffer-toggle :wk "Buffer Toggle")
      "o r f" '(org-roam-node-find  :wk "Node find")
      "o r g" '(org-roam-graph  :wk "Graph")
      "o r i" '(org-roam-node-insert :wk "Node insert")
      "o r c" '(org-roam-capture :wk "Capture")
      "o r j" '(org-roam-dailies-capture-today :wk "dailies capture"))

    ;; programming keybindings
    (ECFPAW/leader-keys
      "p" '(:ignore t :wk "Programming")
      "p e" '(eglot :wk "Turn on eglot")
      "p d" '(eglot-shutdown :wk "shutdown a eglot workspace")
      "p r" '(eglot-rename :wk "eglot-rename")
      "p g" '(xref-find-definitions :wk "go to definition")
      "p d" '(eldoc :wk "get docs")
      "p i" '(helm-imenu :wk "imenu")
      "p a" '(eldoc :wk "eglot code actions")
      "p c" '(outline-minor-mode :wk "enable code-folding"))

    ;; window management keybindings
    (ECFPAW/leader-keys
      "w" '(:ignore t :wk "Windows")
      ;; Window splits
      "w d" '(evil-window-delete :wk "Close window")
      "w x" '(evil-window-delete :wk "Close window")
      "w n" '(evil-window-new :wk "New window")
      "w s" '(evil-window-split :wk "Horizontal split window")
      "w v" '(evil-window-vsplit :wk "Vertical split window") 
      "w /" '(evil-window-vsplit :wk "Vertical split window")
      "w m" '(ECFPAW/toggle-windows-split :wk "Maximize window")
      ;; Window motions
      "w h" '(evil-window-left :wk "Window left")
      "w j" '(evil-window-down :wk "Window down")
      "w k" '(evil-window-up :wk "Window up")
      "w l" '(evil-window-right :wk "Window right")
      "w w" '(evil-window-next :wk "Goto next window")))
  ;; different keybindgings to resize windows.
  (global-set-key (kbd "<C-down>") 'shrink-window)  
  (global-set-key (kbd "<C-up>") 'enlarge-window)  
  (global-set-key (kbd "<C-right>") 'shrink-window-horizontally)  
  (global-set-key (kbd "<C-left>") 'enlarge-window-horizontally)  

      #+end_src
* GRAPHICS
** ALL THE ICONS 
This is an icon set that can be used with dashboard, dired, ibuffer and other Emacs programs.
  
#+begin_src emacs-lisp
  (use-package all-the-icons
    :ensure t
    :if (display-graphic-p))

  (use-package all-the-icons-dired
    :hook (dired-mode . (lambda () (all-the-icons-dired-mode t))))
#+end_src

** FONTS
*** setting the fonts face
Defining the various fonts emacs will use.
#+begin_src elisp
  (set-face-attribute 'default nil
                      :font "Hack"
                      :height 130
                      :weight 'medium)
  (set-face-attribute 'font-lock-comment-face nil
                      :slant 'italic)
  (set-face-attribute 'font-lock-keyword-face nil
                      :slant 'italic)
  ;; Uncomment theh following line if line spacing needs adjusting.
  ;; (setq-default line-spacing 0.12)
#+end_src
*** Zooming In/Out
For =CTRL=/-= zooming shortcuts.
#+begin_src elisp
  (global-set-key (kbd "C-=") 'text-scale-increase)
  (global-set-key (kbd "C--") 'text-scale-decrease)
  (global-set-key (kbd "<C-wheel-up>") 'text-scale-increase)
  (global-set-key (kbd "<C-wheel-down>") 'text-scale-decrease)
#+end_src
** GRAPHICAL USER INTERFACE TWEAKS
Let's make GNU Emacs look a little better.

Mostly just disabling some Emacs features which are for beginners(mostly).
*** Disable Menu bar and Toolbars 
Just too distracting.
#+begin_src elisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
#+end_src

*** Display Line Numbers and Truncated Lines
I like relative line numbers(They help in Evil keybindings).
#+begin_src elisp
  (global-display-line-numbers-mode)
  (global-visual-line-mode t)
#+end_src
*** Disable the scroll bar
Because they are totally unnecessary and I don't use them. Even if I
ever wanted to use my mouse, I would just use my mouse wheel instead
of this.
#+begin_src elisp
  (scroll-bar-mode -1)
#+end_src
** THEME
I will use VSCode themeüóø.
*** Themes
**** Doom Themes
#+begin_src elisp
  (use-package doom-themes
    :ensure t
    :config
    ;; Global settings (defaults)
    (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
          doom-themes-enable-italic t) ; if nil, italics is universally disabled
    ;; Enable flashing mode-line on errors
    ;; (doom-themes-visual-bell-config)

    ;; Corrects (and improves) org-mode's native fontification.
    (doom-themes-org-config)
    (ECFPAW/cycle-my-theme))
#+end_src
**** VSCode theme
#+begin_src elisp
  (use-package vscode-dark-plus-theme
    :ensure t)
#+end_src
**** Catpuccin theme
#+begin_src elisp
(use-package catppuccin-theme :ensure t)
#+end_src
*** Easy cycling
#+begin_src elisp
  (setq my-themes '(vscode-dark-plus doom-gruvbox doom-gruvbox-light))

  (setq my-cur-theme nil)
  (defun ECFPAW/cycle-my-theme ()
    "Cycle through a list of themes, my-themes"
    (interactive)
    (when my-cur-theme
      (disable-theme my-cur-theme)
      (setq my-themes (append my-themes (list my-cur-theme))))
    (setq my-cur-theme (pop my-themes))
    (load-theme my-cur-theme t))
#+end_src
** TRANSPARENCY
With Emacs version 29, true transparency has been added.
#+begin_src elisp
  (add-to-list 'default-frame-alist '(alpha-background . 100)) ; For all new frames henceforth
#+end_src
* LINE NUMBERS
I am using this function because sometimes =absolute= line number is
better than =relative=.
#+begin_src elisp
  (setq ECFPAW/line-number-list '(relative absolute))
  (defun ECFPAW/cycle-line-number-type ()
    "Cycle through line number types"
    (interactive)
    (setq display-line-numbers (pop ECFPAW/line-number-list))
    (setq ECFPAW/line-number-list (append ECFPAW/line-number-list (list display-line-numbers))))

  (ECFPAW/cycle-line-number-type)
#+end_src
* COMPANY
[[https://company-mode.github.io/][Company]] is a text completion framework for Emacs. The name stands for
"complete anything".  Completion will start automatically after you
type a few letters. Use M-n and M-p to select, <return> to complete or
<tab> to complete the common part.

#+begin_quote
Company was giving me troubles, removing all the customization, I
blindly copied from DistroTube worked. Lesson learned.
#+end_quote
#+begin_src emacs-lisp
  (use-package company
    :defer 2
    :init
    (global-company-mode t))

  (use-package
    company-box
    :after company
    :hook (company-mode . company-box-mode))
#+end_src
* DASHBOARD
[[https://github.com/emacs-dashboard/emacs-dashboard][emacs-dashboard]] is an package which allows you to make a nice little
dashboard which comes up when you start Emacs. I also disable the
number lines for this one because it looked ugly.
#+begin_src elisp
  (use-package dashboard
    :ensure t 
    :init
    (setq initial-buffer-choice 'dashboard-open)
    (setq dashboard-set-heading-icons t)
    (setq dashboard-set-file-icons t)
    (setq dashboard-startup-banner (locate-user-emacs-file "images/trancendent-gnu.png"))
    (setq dashboard-banner-logo-title "ECFPAW")
    (setq dashboard-center-content t)
    (setq dashboard-items '((recents . 5)
                            (projects . 5)))
    :config
    (dashboard-setup-startup-hook)
    (add-hook 'dashboard-mode 'display-line-numbers-mode))
#+end_src
* DIRED
Dired is a file manager within Emacs. It comes builtin.
#+begin_src emacs-lisp
  ;; disable overloading with info by default, shift+( to show details
  (add-hook 'dired-mode-hook 'dired-hide-details-mode)
#+end_src
* HELM
[[https://emacs-helm.github.io/helm][helm]] is a completion mechanism. And I am in love with it. I plan to
use it everywhere its possible. I use it for flyspell as well.
#+begin_src emacs-lisp
  (use-package helm
    :demand t
    :config (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action
    (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB work in terminal
    (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z
    (helm-mode +1)
    )

  (use-package helm-flyspell)
  (use-package helm-themes)
#+end_src
* EMOJI
Emojis, I need them.üòÖ
#+begin_src elisp
  (use-package emojify
    :config (setq 'emojify-display-style "unicode")
    :hook (after-init . global-emojify-mode))
#+end_src
* TEXT
Some stuff which are for text editing in general.
** Electric
*** Electric pairs
Adds the next pair for =(= automatically.
#+begin_src elisp
(add-hook 'fundamental-mode-hook 'electric-pair-mode)
#+end_src>
* ORG-MODE
#+begin_quote
...
What is like the org-mode? What can make war against it?
...
#+end_quote
** Enable spell checking by default
#+begin_src elisp
  (add-hook 'org-mode-hook 'flyspell-mode)
#+end_src
** Enable auto-fill mode by default 
I love auto-fill mode it basically wraps the line at 80 characters for
you. So that the line is not too big and readable.
#+begin_src elisp
  (add-hook 'org-mode-hook 'auto-fill-mode)
#+end_src
** Making the *scratch* buffer start in Org-mode
Why not?
#+begin_src elisp
  (setq initial-major-mode 'org-mode)
#+end_src
** Inserting time and date
Here I will make a custom function which will help me insert time and date.
#+begin_src elisp
  (defun ECFPAW/insert-now-timestamp()
    "Insert org mode timestamp at point with current date and time."
    (interactive)
    (org-insert-time-stamp (current-time) t))
#+end_src
** Enabling Org Bullets
Org-bullets look nice.
#+begin_src elisp
  (add-hook 'org-mode-hook 'org-indent-mode)
  (use-package org-bullets)
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
#+end_src
** Enabling org-tempo
This packages allows shortcuts for source blocks etc.
#+begin_src elisp
  (require 'org-tempo)
#+end_src
** LaTeX preview
Org-mode can embed directly into the document. Here I am adjusting the
size and rendering method.
#+begin_src elisp
  (custom-set-variables '(org-format-latex-options
                          '(:foreground default :background default :scale 3 :html-foreground "Black" :html-background "Transparent" :html-scale 1 :matchers
                                        ("begin" "$1" "$" "$$" "\\(" "\\["))))
  (setq org-preview-latex-default-process 'dvisvgm)
#+end_src
** Roam
I want my second brain tooüóø. 
#+begin_src elisp
  (use-package org-roam
    :ensure t
    :custom
    (org-roam-directory (file-truename "~/Documents/roam"))
    :config
    ;; If you're using a vertical completion framework, you might want a more informative completion interface
    (setq org-roam-node-display-template (concat "${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
    (org-roam-db-autosync-mode)
    (setq org-roam-completion-everywhere t)
    ;; If using org-roam-protocol
    (require 'org-roam-protocol))

  (use-package org-roam-ui
    :after org-roam
    ;;         normally we'd recommend hooking orui after org-roam, but since org-roam does not have
    ;;         a hookable mode anymore, you're advised to pick something yourself
    ;;         if you don't care about startup time, use
    ;;  :hook (after-init . org-roam-ui-mode)
    :config
    (setq org-roam-ui-sync-theme t
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start t))
#+end_src
* GIT
[[git-scm.com][Git]] is the best version control system(The only one I have ever
used). You can use it for anything BTW, not just programming. For
instance when writing stories, its convenient to have Git manage the
versions for you.
** MAGIT
Magit (Maggot , magic IDK) is a git client for Emacs.
#+begin_src elisp
  (use-package magit
    :ensure t
    :defer t)
#+end_src
* FLYCHECK
Flycheck can do a lot of stuff including,
- Showing errors in programs,
- Showing spelling errors.
#+begin_src elisp
  (use-package flycheck
    :ensure t
    :defer t
    :init (global-flycheck-mode))
#+end_src
* PROJECTILE 
Projectile is a project interaction library for Emacs.  It should be
noted that many projectile commands do not work if you have set ‚Äúfish‚Äù
as the ‚Äúshell-file-name‚Äù for Emacs.  I had initially set ‚Äúfish‚Äù as the
‚Äúshell-file-name‚Äù in the Vterm section of this config, but oddly
enough I changed it to ‚Äúbin/sh‚Äù and projectile now works as expected,
and Vterm still uses ‚Äúfish‚Äù because my default user ‚Äúsh‚Äù on my Linux
system is ‚Äúfish‚Äù.

I make it use =dired= to open a project instead of just using =find-file=.
#+begin_src elisp
  (use-package projectile
    :config
    (setq projectile-switch-project-action #'projectile-dired)
    (projectile-mode 1))
#+end_src
* LANGUAGE SUPPORT
** LANGUAGE MODES
**** Markdown mode
I still use markdown files for =README= and stuff, (sorry [[*ORG-MODE]]).
#+begin_src elisp
  (use-package markdown-mode
    :config
    (markdown-mode))
#+end_src
**** Python
Setting up Eglot for python. Also setting up black format on save!
#+begin_src elisp
  (add-hook 'python-mode-hook 'eglot-ensure)

  ;; This part is confusing so I just used a seperate package for formatting instead of trying to use Eglot for it.

  ;; (add-hook 'python-mode-hook '(with-eval-after-load 'eglot
  ;;                                (setq-default eglot-workspace-configuration
  ;;                                              '(:pylsp (:plugins (:jedi_completion (:include_params t
  ;;                                                                                                    :fuzzy t)
  ;;                                                                                   :pylint (:enabled :json-false)))
  ;;                                                       :gopls (:usePlaceholders t)))))
  (use-package blacken :config (add-hook 'python-mode-hook 'blacken-mode))

#+end_src
** code folding
#+begin_src elisp
  (add-hook 'python-mode-hook 'outline-minor-mode)
#+end_src
** tree-sit
*** install language grammar
use this SRC block to install support for more languages (You can also
just call it using M-x)
#+begin_src elisp
  ;; (treesit-install-language-grammar "python")
#+end_src
** Eglot
Get the latest version!
#+begin_src elisp
  (use-package eglot :ensure t)
#+end_src
* WHICH-KEY 
=which-key= basically shows the shortcuts you have setup. Its very
useful, because you may not which key you bonded to what.
#+begin_src elisp
  (use-package which-key
    :init
    (which-key-mode 1)
    :config
    (setq
     which-key-side-window-location 'bottom
     which-key-sort-order #'which-key-key-order-alpha
     which-key-sort-uppercase-first nil
     which-key-add-column-padding 1
     which-key-max-display-columns nil
     which-key-min-display-lines 6
     which-key-side-window-slot -10
     which-key-side-window-max-height 0.25
     which-key-idle-delay 0.8
     which-key-max-description-length 25
     which-key-allow-imprecise-window-fit t
     which-key-separator " ‚Üí " )
    )
#+end_src
* SUDO EDIT
[[https://github.com/nflath/sudo-edit][sudo-edit]] gives us the ability to open files with sudo privileges or
switch over to editing with sudo privileges if we initially opened the
file without such privileges.

#+begin_src emacs-lisp
  (use-package sudo-edit
    :config
    (ECFPAW/leader-keys
     "f u" '(sudo-edit-find-file :wk "Sudo find file")
     "f U" '(sudo-edit :wk "Sudo edit file")))
#+end_src

* SHELLS AND TERMINALS
You do need shell, in our editor sometimes...
** Vterm
 Vterm is a terminal emulator within Emacs.  The 'shell-file-name'
 setting sets the shell to be used in M-x shell, M-x term, M-x
 ansi-term and M-x vterm.
 #+begin_src emacs-lisp
   (use-package vterm
     :config
     (setq shell-file-name "/bin/sh"
           vterm-max-scrollback 5000))
 #+end_src
** Vterm-Toggle 
 [[https://github.com/jixiuf/vterm-toggle][vterm-toggle]] toggles between the vterm buffer and whatever buffer you are editing.
 #+begin_src emacs-lisp
   (use-package vterm-toggle
     :after vterm
     :config
     (setq vterm-toggle-fullscreen-p nil)
     (setq vterm-toggle-scope 'project)
     (add-to-list 'display-buffer-alist
                  '((lambda (buffer-or-name _)
                      (let ((buffer (get-buffer buffer-or-name)))
                        (with-current-buffer buffer
                          (or (equal major-mode 'vterm-mode)
                              (string-prefix-p vterm-buffer-name (buffer-name buffer))))))
                    (display-buffer-reuse-window display-buffer-at-bottom)
                    ;;(display-buffer-reuse-window display-buffer-in-direction)
                    ;;display-buffer-in-direction/direction/dedicated is added in emacs27
                    ;;(direction . bottom)
                    ;;(dedicated . t) ;dedicated is supported in emacs27
                    (reusable-frames . visible)
                    (window-height . 0.3))))
 #+end_src

* TRAMP
#+begin_src elisp
  (custom-set-variables
   '(tramp-default-method "ssh")
   '(tramp-default-user "tusharhero"))
#+end_src
* EDIT SERVER
Edit server is an extensions which allows you edit text from your
browser in a very integrated way. Here is a [[https://github.com/stsquad/emacs_chrome][link]] to their git server.
#+begin_src elisp
  (use-package edit-server
    :ensure t
    :commands edit-server-start
    :init (if after-init-time
              (edit-server-start)
            (add-hook 'after-init-hook
                      #'(lambda() (edit-server-start))))
    :config (setq edit-server-new-frame-alist
                  '((name . "Edit with Emacs FRAME")
                    (top . 200)
                    (left . 200)
                    (width . 80)
                    (height . 25)
                    (minibuffer . t)
                    (menu-bar-lines . t)
                    (window-system . x))))
#+end_src

* CUSTOM
Just a place for some custom functions I define.
#+begin_src elisp
  (defun ECFPAW/major-mode-keybinds ()
    "Get the path of file from user-config directory"
    (interactive)
    (setq unread-command-events (listify-key-sequence (kbd "C-c"))))

  ;; Toggle between split windows and a single window
  (defun ECFPAW/toggle-windows-split()
    "Switch back and forth between one window and whatever split of
    windows we might have in the frame. The idea is to maximize the
    current buffer, while being able to go back to the previous split
    of windows in the frame simply by calling this command again."
    (interactive)
    (if (not(window-minibuffer-p (selected-window)))
        (progn
          (if (< 1 (count-windows))
              (progn
                (window-configuration-to-register ?u)
                (delete-other-windows))
            (jump-to-register ?u)))))
#+end_src
