# -*- after-save-hook: (org-babel-tangle); eval: (message "Welcome to ECFPAW's literate configuration."); org-confirm-babel-evaluate: nil; -*-
#+TITLE: Emacs Config For Programming And Writing (ECFPAW)
#+AUTHOR: tusharhero
#+EMAIL: tusharhero@sdf.org
#+DESCRIPTION: It actually does more than just programming and writing.
#+STARTUP: content
#+PROPERTY: header-args :tangle init.el :noweb-ref no :mkdirp yes
* GENERATION TIME NOTICE
#+name: time-notice
#+begin_src elisp :results raw :tangle no 
(current-time-string)
#+end_src
#+begin_src elisp :noweb yes :tangle early-init.el
  ;; This file is a part of ECFPAW,
  ;; configuration was generated by Emacs Org-Mode on `<<time-notice()>>`
#+end_src
#+begin_src elisp :noweb yes :tangle init.el
  ;; This file is a part of ECFPAW,
  ;; configuration was generated by Emacs Org-Mode on `<<time-notice()>>`
#+end_src
* LICENSE NOTICE
  :PROPERTIES:
  :VISIBILITY: folded
  :END:
#+begin_src elisp
  ;; The GPLv3 License (GPLv3)

  ;; Copyright ¬© 2024 tusharhero

  ;; This program is free software: you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with this program.  If not, see <http://www.gnu.org/licenses/>.
#+end_src

* TODO CHORES [1/5]
** TODO Use =use-package= properly to reduce startup time.
** TODO Add more key bindings.
*** TODO Add shortcut to bold, italicize, etc. in [[ORG-MODE]].
** TODO Correct the key bindings for annot-list mode.
** TODO Divide this TODO into respective categories in their correct place.
** DONE Completely overhaul the way I do keybindings.
* BOOTSTRAPPING
#+begin_src elisp :tangle bootstrap-config.el :shebang #!/usr/bin/env -S emacs --script
;; Run this script to 'bootstrap' ECFPAW from `config.org', of
;; course the only requirement it has is Emacs is itself.
(message "Loading Org...")
(require 'org)
(message "Tangling config.org...")
(org-babel-tangle-file "config.org")
(message "ECFPAW has been bootstrapped!")
#+end_src
* EARLY-INIT (SUPER EARLY)
** Disable inbuilt package manager
#+begin_src emacs-lisp :tangle early-init.el
  (setq package-enable-at-startup nil)
#+end_src
** Startup optimization
It took 2.7-3 seconds before these optimizations, and now it is 1
seconds.
*** Garbage collection
Minimize garbage collection before startup and then go back to the
default value (8 MiB) after startup.
#+begin_src elisp :tangle early-init.el
(setq gc-cons-threshold most-positive-fixnum)
(add-hook 'emacs-startup-hook
          (lambda ()
            (setq gc-cons-threshold (expt 2 23))))
#+end_src
* IMPORTANT PROGRAMS TO LOAD FIRST
** Package Manager
I am going to use [[https://github.com/progfolio/elpaca][Elapaca]] package manager. You might want to check for
the new installer version on their git repository.
#+BEGIN_SRC elisp
  (defvar elpaca-installer-version 0.8)
  (defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
  (defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
  (defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
  (defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                                :ref nil :depth 1
                                :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                                :build (:not elpaca--activate-package)))
  (let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
         (build (expand-file-name "elpaca/" elpaca-builds-directory))
         (order (cdr elpaca-order))
         (default-directory repo))
    (add-to-list 'load-path (if (file-exists-p build) build repo))
    (unless (file-exists-p repo)
      (make-directory repo t)
      (when (< emacs-major-version 28) (require 'subr-x))
      (condition-case-unless-debug err
          (if-let* ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                    ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
                                                    ,@(when-let* ((depth (plist-get order :depth)))
                                                        (list (format "--depth=%d" depth) "--no-single-branch"))
                                                    ,(plist-get order :repo) ,repo))))
                    ((zerop (call-process "git" nil buffer t "checkout"
                                          (or (plist-get order :ref) "--"))))
                    (emacs (concat invocation-directory invocation-name))
                    ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                          "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                    ((require 'elpaca))
                    ((elpaca-generate-autoloads "elpaca" repo)))
              (progn (message "%s" (buffer-string)) (kill-buffer buffer))
            (error "%s" (with-current-buffer buffer (buffer-string))))
        ((error) (warn "%s" err) (delete-directory repo 'recursive))))
    (unless (require 'elpaca-autoloads nil t)
      (require 'elpaca)
      (elpaca-generate-autoloads "elpaca" repo)
      (load "./elpaca-autoloads")))
  (add-hook 'after-init-hook #'elpaca-process-queues)
  (elpaca `(,@elpaca-order))
#+END_SRC
** use-package support.
[[https://jwiegley.github.io/use-package/][use-package]] is useful for configuring and installing packages.
#+begin_src elisp
  ;; Install use-package support
  (elpaca elpaca-use-package
    ;; Enable :ensure use-package keyword.
    (elpaca-use-package-mode)
    ;; Assume :ensure t unless otherwise specified.
    (setq elpaca-use-package-by-default t))
  ;; Block until current queue processed.
  (elpaca-wait)
#+end_src
* Emacs lisp vulnerability mitigation.
This is for [[https://nvd.nist.gov/vuln/detail/CVE-2024-53920][CVE-2024-53920]].
#+begin_src elisp
  (setq auto-mode-alist (rassq-delete-all 'emacs-lisp-mode auto-mode-alist))
  (setq auto-mode-alist (rassq-delete-all 'elisp-byte-code-mode auto-mode-alist))
#+end_src
* Generally useful helper functions
There functions are generally useful.
#+begin_src elisp
  (defun ECFPAW/make-cyclic-list (list)
    "Create a cyclic list."
    (when list
      (setf (cdr (last list)) list)))

  (defun ECFPAW/is-it-day ()
    "Return a boolean representation of whether its day or not.
  Any time between 6 and 18 is defined as day."
    (interactive)
    (< 6 (decoded-time-hour (decode-time (current-time))) 18))
#+end_src
* DISABLE BELL
It's very annoying to have that bell ringing all the time.
#+begin_src elisp
(setq visible-bell t)
(setq ring-bell-function 'ignore)
#+end_src
* FILES
Make emacs stop littering my directories with backup files üòÑ.
#+begin_src elisp
  (setq backup-directory-alist '("." . ".emacs-file-backups"))
#+end_src
* WHICH-KEY 
=which-key= basically shows all the keybindings.
#+begin_src elisp
  (use-package which-key :init  (which-key-mode))
#+end_src
* Custom keybindings
I will try to keep these to a minimum. Setting up custom keybindings
and maintaining them is a headache.
** Org
#+begin_src elisp
  (keymap-global-set "C-c a" 'org-agenda)
  (keymap-global-set "C-c c" 'org-capture)
#+end_src
* Key Statistics
I need to get some keybinding statistics to improve my keybindings situation.
#+begin_src elisp
  (use-package keyfreq
    :config (keyfreq-mode 1)
    (keyfreq-autosave-mode 1))
#+end_src
* GRAPHICS
** ALL THE ICONS 
This is an icon set that can be used with dashboard, dired, ibuffer
and other Emacs programs.
  
BTW, you need to run =all-the-icons-install-fonts=.
#+begin_src emacs-lisp
  (use-package all-the-icons
    :ensure t
    :if (display-graphic-p))

  (use-package all-the-icons-dired
    :hook (dired-mode . (lambda () (all-the-icons-dired-mode t))))
#+end_src

** FONTS
*** setting the fonts face
Defining the various fonts Emacs will use.
#+begin_src elisp
  (add-to-list 'default-frame-alist
               '(font . "Iosevka NF 14"))
#+end_src
** GRAPHICAL USER INTERFACE TWEAKS
Let's make GNU Emacs look a little better.

Mostly just disabling some Emacs features which are for beginners(mostly).
*** Disable Menu bar and Toolbars 
Just too distracting.
#+begin_src elisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
#+end_src
*** Disable the scroll bar
Because they are totally unnecessary and I don't use them. Even if I
ever wanted to use my mouse, I would just use my mouse wheel instead
of this.
#+begin_src elisp
  (scroll-bar-mode -1)
#+end_src
*** Start in maximised mode
#+begin_src elisp
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src
*** Disable comp warnings
#+begin_src elisp
  (custom-set-variables '(warning-suppress-types '((comp))))
#+end_src
** Spacious Padding
Oh, man this single-handedly makes ECFPAW look so much better. Thanks Prot!
#+begin_src elisp
  (use-package spacious-padding
     :config (spacious-padding-mode t))
#+end_src
** Pulsar
*** Introduction
=Pulsar= provides the sweet *pulsing* of light you see when you switch
you buffers, or go to a place in the buffer. It's super nice for
knowing where you are.

Evaluate this to get a pulse üòÑ.
#+begin_src elisp :tangle no
(pulsar-pulse-line)
#+end_src
*** basic setup
#+begin_src elisp
  (use-package pulsar :config
    (setq pulsar-pulse t)
    (setq pulsar-delay 0.2)
    (setq pulsar-iterations 2)
    (setq pulsar-face 'pulsar-magenta)
    (setq pulsar-highlight-face 'pulsar-yellow)
    (add-hook 'next-error-hook #'pulsar-pulse-line)
    (add-hook 'minibuffer-setup-hook #'pulsar-pulse-line)

    ;; integration with the built-in `imenu':
    (add-hook 'imenu-after-jump-hook #'pulsar-recenter-top)
    (add-hook 'imenu-after-jump-hook #'pulsar-reveal-entry)
    (pulsar-global-mode 1))
#+end_src
** THEME
I use Modus themes.
*** Extra Themes
**** Ef-themes
#+begin_src elisp
  (use-package ef-themes :ensure t)
#+end_src
*** Easy cycling
:TODO:
+ [ ] Figure out a way to automatically wait for the correct package to
  load before running ~ECFPAW/cycle-theme~, I tried doing it using
  this code, but that does not really work.
  #+begin_src elisp :tangle no
  (with-eval-after-load (car ECFPAW/themes)
    (ECFPAW/cycle-my-theme))
  #+end_src
:END:
I have a custom function for loading and cycling through my preferred themes.
#+begin_src elisp
  (defvar ECFPAW/themes (ECFPAW/make-cyclic-list
                         (list 'modus-vivendi 'modus-operandi))
    "A list of the themes I like and use.")

  (setq custom-safe-themes t)
  (advice-add 'load-theme
              :before (lambda (theme &optional no-confirm no-enable)
                        (disable-theme (car custom-enabled-themes))
                        (spacious-padding-mode t)))

  (defun ECFPAW/cycle-my-theme ()
    "Cycle through a list of themes, `ECFPAW/themes'."
    (interactive)
    (load-theme (pop ECFPAW/themes) t))
#+end_src
*** Day and night switching
This is used to make theme switch to the light theme at day and the
dark theme at night.
#+begin_src elisp
(use-package circadian
  :ensure t
  :config
  (setq circadian-themes '(("6:00" . modus-operandi)
                           ("18:00" . modus-vivendi)))
  (circadian-setup))
#+end_src
** TRANSPARENCY
With Emacs version 29, true transparency has been added.
*** Setting initial transparency
#+begin_src elisp
  (add-to-list 'default-frame-alist '(alpha-background . 100)) ; For all new frames henceforth
#+end_src
*** Function to change the transparency of the current frame.
**** COMMENT Xorg
I should be modifying =alpha-background= but that doesn't seem to be
going well. So I will modify =alpha= instead. =alpha-background= just
changes the background transparency, =alpha= on the other hand changes
the transparency of the entire buffer. For now the only way to get
background transparency is to modify the variable in the above
function and make a frame unfortunately.
#+begin_src elisp
  (defun ECFPAW/change-current-transparency-to (alpha-val)
    "Change the transparency to the given value"
    (interactive "nChange transparency: ")
    (set-frame-parameter (selected-frame) 'alpha alpha-val))
#+end_src
**** Wayland
This works only on Wayland, So disable it and enable the block above.
#+begin_src elisp
  (defun ECFPAW/change-current-transparency-to (alpha-val)
    "Change the transparency to the given value"
    (interactive "nChange transparency: ")
    (set-frame-parameter (selected-frame) 'alpha-background alpha-val))
#+end_src
* MODE-LINE
I am going to make my own mode-line, I followed [[https://protesilaos.com/codelog/2023-07-29-emacs-custom-modeline-tutorial/][Prot's tutorial]].
** Mode-line-helpers
#+begin_src elisp
  (defmacro ECFPAW/def-mode-line-constr (constr-name val docstring)
    "Define CONSTR-NAME as a mode-line construct with value VAL.
  DOCSTRING is used a docstring."
    `(progn (defvar-local ,constr-name ,val ,docstring)
           (put ',constr-name 'risky-local-variable t)))
#+end_src
** Mode-line formats
I used to copy this format manually.
#+begin_src elisp
  (defvar ECFPAW/mode-line/default-format
    (default-value 'mode-line-format)
    "The vanilla default Emacs mode line format.")
#+end_src

The format works with PDF view mode too now (it displays the page
number properly). Also removed some cosmetic noise from here.
#+begin_src elisp
  (defvar ECFPAW/mode-line/format
    '(""
      mode-line-front-space
      ECFPAW/mode-line/major-mode
      " "
      mode-line-buffer-identification
      " "
      mode-line-position
      " "
      mode-line-misc-info
      " "
      mode-line-format-right-align
      ECFPAW/mode-line/time
      mode-line-end-spaces
      )
    "ECFPAW's mode line format."
    )
#+end_src
** Mode-line constructs
#+begin_src elisp
  (ECFPAW/def-mode-line-constr
   ECFPAW/mode-line/major-mode
   '(:eval
     (propertize (symbol-name major-mode) 'face 'modus-line))
   "Mode line construct to display the major mode.")

  (ECFPAW/def-mode-line-constr
   ECFPAW/mode-line/time
   '(:eval
     (propertize
      (format-time-string "%R %a %d-%b-%y")
      'face 'mode-line
      'help-echo
      (current-time-string)
      'mouse-face 'mode-line-highlight))
   "Mode line construct to display the time")
#+end_src
** Default mode-line, and cycling.

#+begin_src elisp
  (setq-default mode-line-format ECFPAW/mode-line/format)
#+end_src

#+begin_src elisp
  (defvar ECFPAW/mode-line/formats
    '(ECFPAW/mode-line/format
      ECFPAW/mode-line/default-format)
    "A list of all the modelines available.")

  (defun ECFPAW/mode-line/switch-to-format (format)
    "Switch to mode-line `FORMAT'."
    (interactive
     (list (eval
  	  (intern (completing-read
  		   "Switch to mode-line format: "
      		   ECFPAW/mode-line/formats)))))
    (setq mode-line-format  format)
    (force-mode-line-update))
#+end_src
** Diminish modes
Hide some minor modes.
#+begin_src elisp
  (use-package diminish
    :defer 3
    :config
    (diminish 'which-key-mode))
#+end_src

* LINE NUMBERS
I am using this function because sometimes =absolute= line number is
better than =relative=. And I have decided to *NOT* enable these by
default because they are super distracting.
#+begin_src elisp
    (defvar ECFPAW/line-number-list
      (ECFPAW/make-cyclic-list (list 'relative 'absolute))
      "list of line numbers")

    (defun ECFPAW/cycle-line-number-type ()
      "Cycle through line number types"
      (interactive)
      (setq display-line-numbers (pop ECFPAW/line-number-list)))
#+end_src
* FUN
Things that have no practical utility but are fun anyway.
** Zone out
This does fun things where you stop using Emacs for a while.
*** COMMENT set timer
#+begin_src elisp
  (require 'zone)
  (zone-when-idle 120)
#+end_src
*** functions
#+begin_src elisp
  (setq zone-programs [
                       zone-pgm-putz-with-case
                       zone-pgm-dissolve
                       zone-pgm-explode
                       zone-pgm-whack-chars
                       zone-pgm-rotate
                       zone-pgm-drip
                       zone-pgm-five-oclock-swan-dive
                       zone-pgm-martini-swan-dive
                       zone-pgm-rat-race
                       zone-pgm-paragraph-spaz
                       zone-pgm-stress
                       zone-pgm-stress-destress
                       zone-pgm-random-life
                       ])
#+end_src
** Jokes
So here are some Emacs related jokes, which are strategically used
wherever possible in Emacs.
#+begin_src elisp
  (defvar ECFPAW/jokes (list
                     "What is like the org-mode? What can make war against it?"
                     "I teach Quantum Mechanics to toddlers."
                     "STOP HAVING FUN !!! üò†"
                     "Why did the Emacs user switch to Vim? Because they wanted to be able to exit the editor."
                     "Emacs is a good operating system, it just lacks a good text editor (komediüòÜ)"
                     ) "List of Jokes.")
#+end_src
* LLM-SUPPORT
I like to use Ollama on my local(and remote) computers üòÑ.
** Ollama management
I find myself needing to manage my ollama instances.
*** Get request for emacs
I need a requests library because url is too much of a pain to use.
#+begin_src elisp
  (use-package plz)
#+end_src
*** Get a list of Ollama instances
#+begin_src elisp
  (defun ECFPAW/ollama-get-model-names (ollama-host)
      "Gets the names of models available in OLLAMA-HOST as a list."
      (require 'plz)
      (mapcar (lambda (model) (alist-get 'name model))
              (alist-get 'models
                         (plz 'get
                           (format "http://%s/api/tags" ollama-host)
                           :as #'json-read))))
#+end_src
*** Add Ollama models
:TODO:
+ [ ] Fix this function as currently, it just calls the API waits for
  the first response and then immediately.
:END:
#+begin_src elisp
  (defun ECFPAW/ollama-pull-model (ollama-host model-name)
    "Pull model named MODEL-NAME in OLLAMA-HOST."
    (interactive "MOllama host: \nMModel name: ")
    (require 'plz)
    (plz 'post (format "http://%s/api/pull" ollama-host)
      :headers '(("Content-Type" . "application/json"))
      :body (json-encode '(("name" . model-name)))
      :as #'json-read))
#+end_src
** GPTEL
*** Configuration
I currently just use Ollama, I have 2 backends defined one of them is
the local Ollama backend which uses the port ~11434~, the other one is
the remote backend, which uses the port ~11435~. You are supposed use
ssh redirection to redirect your remote ollama server to the port ~11435~.

To redirect any port from a remote machine, use the following command:
#+begin_src shell :tangle no
ssh -L local_port:remote_address:remote_port username@server.com
#+end_src
#+begin_src elisp
  (use-package gptel
    :ensure (:host github :repo "karthink/gptel" :branch "copilot")
    :config

    (defun ECFPAW/load-models ()
      (interactive)
      (let* ((host "localhost:11434")
             (models (condition-case nil
                         (ECFPAW/ollama-get-model-names host)
                       (plz-error nil))))
        (setq-default gptel-model (car models)
                      gptel-backend (gptel-make-ollama "Ollama"
                                      :host host
                                      :stream t
                                      :models models)))
      (add-hook 'gptel-mode-hook 'ECFPAW/load-models)

      (let ((host "localhost:11435"))
        (gptel-make-ollama "Ollama(remote)"
          :host host
          :stream t
          :models (condition-case nil
                      (ECFPAW/ollama-get-model-names host)
                    (plz-error nil)))))
    (ECFPAW/load-models)
    (add-hook 'gptel-post-response-functions 'gptel-end-of-response))
#+end_src
*** System Prompts
:TODO:
+ [X] Perhaps write elisp code extract this info from an org-tree instead.
:END:
We will just set the directives by taking them from [[Prompts]].
#+NAME: prompts
#+begin_src elisp :tangle no :noweb yes :eval yes :results raw
  `(setq gptel-directives 
  ',(mapcar
   (lambda (prompt)
     `(,(intern (car prompt)) . ,(cadr prompt)))
   (cdr (org-map-entries
         (lambda ()
           `(,(substring-no-properties
               (org-get-heading))
             ,(format "\"%s\"" (substring-no-properties
               (org-agenda-get-some-entry-text (point-marker) most-positive-fixnum)))))
         "prompts"))))
#+end_src
#+begin_src elisp :noweb yes
<<prompts()>>
#+end_src
**** Prompts                                                     :prompts:
This org-tree contains the actual prompts.
***** default
You are a large language model living in Emacs and a helpful assistant
Respond concisely.
***** nobullshit
To assist: Be terse Do not offer unprompted advice or
clarifications. Speak in specific, topic relevant terminology Do NOT
hedge or qualify. Do not waffle. Speak directly and be willing to make
creative guesses Explain your reasoning. if you don‚Äôt know, say you
don‚Äôt know

Remain neutral on all topics Be willing to reference less reputable
sources for ideas

Never apologize Ask questions when unsure.
***** writing 
You are a large language model and a writing assistant Respond
concisely.
***** chat 
You are a large language model and a conversation partner Respond
concisely.
***** programmer 
You are a careful programmer Provide code and only code as output
without any additional text, prompt or note
***** cliwhiz 
You are a command line helper Generate command line commands that do
what is requested, without any additional description or explanation
Generate ONLY the command, I will edit it myself before running
***** emacser 
You are an Emacs maven Reply only with the most appropriate built-in
Emacs command for the task I specify Do NOT generate any additional
description or explanation
***** explain 
Explain what this code does to a novice programmer
***** overtlyrational 
You are rationalAI, an extremely rational chatbot You will always take
the side of evidence and reason You will reject any ideas which are
irrational You only care about being rational and nothing else.  You
will not give any explanations or clarifications for your position,
you will talk to the point You will not claim to hold no position, You
will hold a position in accordance with reason and evidence ONLY You
will NOT write word salads, you will only talk sense
***** gitcoomitor
Read the prompt calmly and read each addition, deletion and no-changed
line carefully.  Focus on changes, not only last or first, figure out
the main idea of the input.  If complex, break it down into smaller
parts to organize your thoughts.  Then, craft a good commit message
based on the input context.  Write a commit message based on the git
diff. Read the diff below and write a commit message that describes
the changes made.
* Overlay
Overlays are like text properties but for the buffer instead of the
string.

Just some helper functions to use them easily.
#+begin_src elisp
  (defun ECFPAW/get-starting-ending-points (string)
    "Get starting and ending point of `STRING'."
    (save-excursion
    (search-forward string)
    `(,(match-beginning 0) ,(match-end 0))))

  (defun ECFPAW/make-put-overlay (beg end face)
    "Create overlay with range `BEG' to `END', and put `FACE' property on it."
    (overlay-put (make-overlay beg end) 'face face))

  (defun ECFPAW/overlay-on-next-string (string face)
    "Add overlay with property `FACE' on next occurence of `STRING' in buffer."
    (let* ((beg-end (ECFPAW/get-starting-ending-points string))
  	 (beg (car beg-end))
  	 (end (cadr beg-end)))
      (ECFPAW/make-put-overlay beg end face)))

  (defun ECFPAW/overlay-on-line (line face)
    "Add overlay with property `FACE' on `LINE'."
    (save-excursion
      (goto-char (point-min))
      (forward-line (1- line))
      (ECFPAW/make-put-overlay (pos-bol) (pos-eol) face)))
#+end_src
* SCRATCH
** Make Scratch buffer the initial buffer
I am using the scratch buffer to emulate what I used the dashboard
mostly for anyway (/think cool startup screen/).
#+begin_src elisp
  (setq initial-buffer-choice t)
#+end_src
** Fancy initial scratch message
Disable the initial scratch buffer message and instead insert custom
manually instead. This is because Emacs tries doing some /smart/ things with it
which makes it harder to work with. Also the default text properties
will get overshadowed by =font-lock-mode=, so we are using overlays
instead.

#+begin_src elisp
  (setq initial-scratch-message nil)

  (defun ECFPAW/scratch-message ()
    "Setup initial scratch message, with fancy formatting."
    (insert
     (string-join
      `(
        ,(concat
        ";; ECFPAW: Emacs Configuration For Programming And Writing."
        " -*- lexical-binding: t; -*-"
        )
        ,(emacs-init-time ";; Initialized in %f seconds.")
        ,(format ";; jokes: \"%s\"" (seq-random-elt ECFPAW/jokes))
        "\n;; This is the Scratch buffer."
        "\n"
        )
      "\n"))
    (save-excursion
      (goto-char (point-min))
      (ECFPAW/overlay-on-next-string "ECFPAW" 'ECFPAW/scratch-buffer-title)
      (ECFPAW/overlay-on-line 2 'ECFPAW/scratch-buffer-subtitle)
      (ECFPAW/overlay-on-line 3 'ECFPAW/scratch-buffer-subtitle)
      ))

  (add-hook 'lisp-interaction-mode-hook 'ECFPAW/scratch-message)
#+end_src

Just for a /little fanciness/.
#+begin_src elisp
  (defface ECFPAW/scratch-buffer-title '((t :height 2.0 :slant italic :weight heavy))
    "Face used for fancy title in scratch buffer.")
  (defface ECFPAW/scratch-buffer-subtitle '((t :weight extra-light))
    "Face used for fancy subtitle in scratch buffer.")
#+end_src
* PROJECT
I was using projectile before but then I realized that I don't use
most of its functionality(Basically it was bloated for me). That is
why I have decided to switch to =project.el=, the builtin project
management functionality of Emacs.
#+begin_src elisp
  (setq project-switch-commands 'project-find-dir)
#+end_src
* DIRED
Dired is a file manager within Emacs. It comes builtin.
** Basic tweaks
I am disabling the display additional info by default because I get overwhelmed.
#+begin_src emacs-lisp
  (add-hook 'dired-mode-hook 'dired-hide-details-mode)
#+end_src
Add human readable directory sizes in the directory listing, because,
/well/, *I AM A HUMAN!*
#+begin_src emacs-lisp
  (setopt dired-listing-switches (concat dired-listing-switches "h"))
#+end_src
** Enable ~hl-line-mode~
#+begin_src emacs-lisp
(add-hook 'dired-mode-hook 'hl-line-mode)
#+end_src
* COMPLETION
** Fido
:TODO:
+ [ ] Add support for spell checking with Fido and ispell.
:END:
#+begin_quote
Friendship ended with Helm, Fido is my new friend.
#+end_quote
To just ignore the completion suggestion and just enter what you
typed use ~M-j~ keybinding.
#+begin_src emacs-lisp
  (fido-mode)
  (fido-vertical-mode)
#+end_src
** Corfu
:TODO:
+ [X] Fix this corfu error
#+begin_example
Error running timer ‚Äòcorfu--auto-complete-deferred‚Äô: (wrong-number-of-arguments #<subr evil-normalize-keymaps> 4)
#+end_example
Fixed by removing evil!
+ [ ] Setup the cape extensions properly
+ [X] Foreshadowing completion support for most cases... Basically I
  need this package , https://code.bsdgeek.org/adam/corfu-candidate-overlay
  I need to do a bit more research though because a lot of stuff uses
  my =TAB= key.
+ [ ] Fix it for use without evil.
:END:
I used to use Company but that had some issue like, dictionary
disabling all the other symbols.

To complete, please use ~C-<tab>~

The following configuration has been copied from this [[https://github.com/Icy-Thought/emacs.d/blob/main/irkalla/site-lisp/editor/coding/init-corfu.el][config]]. (They
helped me with this setup :) )
#+begin_src emacs-lisp
  (use-package corfu
    :preface
    (defun corfu-enable-in-minibuffer ()
      "Enable Corfu in the minibuffer if `completion-at-point' is bound."
      (when (where-is-internal #'completion-at-point (list (current-local-map)))
        (setq-local corfu-echo-delay nil
                    corfu-popupinfo-delay nil)
        (corfu-mode 1)))
    :hook ((elpaca-after-init . global-corfu-mode)
           (minibuffer-setup . corfu-enable-in-minibuffer))
    :custom
    (corfu-cycle t)
    (corfu-preselect t)
    (corfu-count 5)
    (corfu-scroll-margin 5)
    (corfu-separator ?\s)
    (corfu-on-exact-match nil)
    (corfu-preview-current 'insert)
    (corfu-quit-no-match 'separator))

  (use-package corfu-terminal
    :unless window-system
    :hook (corfu-mode . corfu-terminal-mode))

  ;; :NOTE| Posframe like completion menu
  (use-package corfu-popupinfo
    :ensure nil
    :hook (corfu-mode . corfu-popupinfo-mode)
    :custom (corfu-popupinfo-delay '(0.5 . 0.2)))

  ;; :NOTE| Completion at point through Cape
  (use-package cape
    :preface
    (defun setup-cape-extensions ()
      (dolist (cape-fn '(dict emoji)) ;; keyword file  dabbrev tex emoji elisp-symbol))
        (add-to-list 'completion-at-point-functions (intern (format "cape-%s" cape-fn)))))
    :hook (corfu-mode . setup-cape-extensions))

  (use-package corfu-candidate-overlay
    :after corfu
    :config
    ;; enable corfu-candidate-overlay mode globally
    ;; this relies on having corfu-auto set to nil
    (corfu-candidate-overlay-mode t))
#+end_src
* TEXT
Some stuff which are for text editing in general.
** Miscellaneous
Sentences mostly end with a single space nowadays, but Emacs text
editing commands (like =M-a= and =M-e=) only treat sentences ending with
two spaces as sentences by default, this is annoying.
#+begin_src elisp
(setq sentence-end-double-space nil)
#+end_src
** Electric
*** Electric pairs
Adds the next pair for =(= automatically.
#+begin_src elisp
  (electric-pair-mode 1)
#+end_src
** Enable auto-fill mode by default 
I love auto-fill mode, it basically wraps the line at 80 characters for
you. So that the line is not too big and readable.
#+begin_src elisp
  (add-hook 'text-mode-hook 'auto-fill-mode)
#+end_src
** Prettify mode
*** enabling it globally
#+begin_src elisp
  (setq prettify-symbols-unprettify-at-point t)
  (global-prettify-symbols-mode)
#+end_src
*** Create symbol packs
**** Marco for creating symbol pack
This macro will create a function which can then be hooked to the mode
you want to hook them to üíÄ. My mind is struggling to comprehend that.
#+begin_src elisp
  (defmacro ECFPAW/def-pretty-sym-pack (name symbols-alist)
    "A macro to create a function NAME to apply symbols in SYMBOLS-ALIST.
  The generated function can be hooked to any mode."
    `(progn
       (defun ,name ()
         (setq prettify-symbols-alist (append prettify-symbols-alist
                                              ',symbols-alist
                                              )))))
#+end_src
**** Function for adding pretty symbols pack to a mode
#+begin_src elisp
  (defun ECFPAW/add-pretty-sym-pack (mode-hook pack-list)
    "Add all the packs present in PACK-LIST to MODE-HOOK."
    (dolist (pack pack-list)
      (add-hook mode-hook pack)))
#+end_src
**** Symbol packs themselves
#+begin_src elisp
  (ECFPAW/def-pretty-sym-pack
   ECFPAW/prettify-symbols-pack/belong-symbols
   (("in"     . #x2208)
    ("not in" . #x2209)))

  (ECFPAW/def-pretty-sym-pack
   ECFPAW/prettify-symbols-pack/in-equalities
   (("<="     .  "‚â§" )
    (">="     .  "‚â•" )
    ("=="     .  "‚âü" )
    ("!="     .  "‚â†" )))

  (ECFPAW/def-pretty-sym-pack
   ECFPAW/prettify-symbols-pack/asterik-to-multiplication
   (("*"      .   "√ó")))

  (ECFPAW/def-pretty-sym-pack
   ECFPAW/prettify-symbols-pack/lambda
   (("lambda" .  955 )))

  (ECFPAW/def-pretty-sym-pack
   ECFPAW/prettify-symbols-pack/function
   (("def"    .  "ùíª")))

  (ECFPAW/def-pretty-sym-pack
   ECFPAW/prettify-symbols-pack/pointers
   (("->"     . "‚Üí ")
    ("=>"     . "‚áí ")
    ("<-"     . "‚Üê ")))

  (ECFPAW/def-pretty-sym-pack
   ECFPAW/prettify-symbols-pack/redirections
   (("<<"     . "‚â™")
    (">>"     . "‚â´")
    ("<<"     . "‚â™")
    (">>"     . "‚â´")))

  (ECFPAW/def-pretty-sym-pack
   ECFPAW/prettify-symbols-pack/org-checkboxes
   (
    ("[ ]" . "‚òê  ")
    ("[-]" . #("‚ñ°‚Äì" 0 2 (composition ((2)))))
    ("[X]" . "‚òë  ")))
#+end_src
** Enable narrow to region
#+begin_src elisp
  (put 'narrow-to-region 'disabled nil)
#+end_src
** For focused writing
#+begin_src elisp
  (use-package olivetti
    :config
    (setq-default olivetti-body-width 80))
#+end_src
* MANUALS
This will solve any issues I have with documentation.
** Texinfo
Add info manual from a custom location.
#+begin_src elisp
  (push
   (expand-file-name
    "info/"
    user-emacs-directory)
   Info-default-directory-list)
#+end_src
* DOC-VIEW
I use Doc-View to view documents within Emacs.
#+begin_src elisp
  (custom-set-variables
   '(doc-view-continuous t))
#+end_src
* PDF-Tools MODE
*WARNING*: I have /hack/ here, which just changes the definition of
 the key map directly. I should do it more *properly*. I also directly
 start with follow minor mode instead of starting with the normal mode.
#+begin_src elisp
  (use-package pdf-tools :init (pdf-loader-install)
    :config
    (add-hook 'pdf-annot-list-mode-hook 'pdf-annot-list-follow-minor-mode)
    (setq pdf-annot-list-mode-map
    (let ((km (make-sparse-keymap)))
      (define-key km (kbd "C-c C-f") #'pdf-annot-list-follow-minor-mode)
      (define-key km (kbd "C-<return>") #'pdf-annot-list-display-annotation-from-id)
      km))
    )
#+end_src
* CASUAL
Casual is like [[*MAGIT][magit]] but for other things as well.

It excellent for discoverability, the only reason I am able to use:
- =calc=
- =calendar=

I am sure I will slowly discover more Emacs functionality, and casual
interfaces from them.
#+begin_src elisp
  (use-package casual
    :after calc
    :config
    (keymap-set calc-mode-map "C-c l" #'casual-calc-tmenu)
    (keymap-set calendar-mode-map "C-c l" #'casual-calendar))
#+end_src
* ORG-MODE
#+begin_quote
...
What is like the org-mode? What can make war against it?
...
#+end_quote
** Enable spell checking by default
#+begin_src elisp
  (add-hook 'org-mode-hook 'flyspell-mode)
#+end_src
** Inserting time and date
Here I will make a custom function which will help me insert time and date.
#+begin_src elisp
  (defun ECFPAW/insert-now-timestamp()
    "Insert org mode timestamp at point with current date and time."
    (interactive)
    (org-insert-time-stamp (current-time) t))
#+end_src
** Org-indent
It indents the org tree so its nice to look at.
#+begin_src elisp
  (add-hook 'org-mode-hook 'org-indent-mode)
#+end_src
** Hide emphasis markers
I /decided/ that I don't like to see *emphasis* markers in org-mode.
#+begin_src elisp
(setq org-hide-emphasis-markers t)
#+end_src
** Enabling Org Superstar
Org-Superstar look nice.
#+begin_src elisp
  (use-package org-superstar
    :config
    (add-hook 'org-mode-hook (lambda () (org-superstar-mode 1))))
#+end_src
** Enabling org-tempo
This packages allows shortcuts for source blocks etc.
#+begin_src elisp
  (require 'org-tempo)
#+end_src
***  Fix Electric mode inhibiting tempo
#+begin_src elisp
(add-hook 'org-mode-hook (lambda ()
           (setq-local electric-pair-inhibit-predicate
                   `(lambda (c)
                  (if (char-equal c ?<) t (,electric-pair-inhibit-predicate c))))))
#+end_src
** LaTeX preview
Org-mode can embed directly into the document. Here I am adjusting the
size and rendering method.
#+begin_src elisp
  (custom-set-variables '(org-format-latex-options
                          '(:foreground default :background default :scale 3 :html-foreground "Black" :html-background "Transparent" :html-scale 1 :matchers
                                        ("begin" "$1" "$" "$$" "\\(" "\\["))))
  (setq org-preview-latex-default-process 'imagemagick)
#+end_src
** COMMENT Latex math support
#+begin_src elisp
  (use-package cdlatex)
  (add-hook 'org-mode-hook #'turn-on-org-cdlatex)
  (defun ECFPAW/org-latex-yas ()
    "Activate org and LaTeX yas expansion in org-mode buffers."
    (yas-minor-mode)
    (yas-activate-extra-mode 'latex-mode))

  (add-hook 'org-mode-hook #'ECFPAW/org-latex-yas)
#+end_src
** Journal and Task
*** Agenda and capturing
#+begin_src elisp :var goals-directory="~/Documents/goals/"
  (setq org-capture-templates
        `(("t" "Todo" entry (file+headline
                             ,(concat goals-directory "tasks.org") "Tasks")
           "* TODO %?\n  %i\n  %a")
          ("j" "Journal" entry (file+datetree
                                ,(concat goals-directory "journal.org"))
           "* %?\nEntered on %U\n  %i\n  %a")))
  (setq org-agenda-files `(,(concat goals-directory "tasks.org")
                           ,(concat goals-directory "journal.org")))
#+end_src

Add breadcrumbs because I get confused about which task I am looking at.
#+begin_src elisp
  (setq org-agenda-prefix-format
        '((agenda . " %i %-12:b%?-12t% s") (todo . " %i %-12:c")
    	(tags . " %i %-12:c") (search . " %i %-12:c")))
#+end_src


#+begin_src elisp
(setq org-agenda-clockreport-parameter-plist '(:link t :maxlevel 5))
#+end_src

Its just annoying to look at this point.
#+begin_src elisp
(setq org-agenda-show-future-repeats nil)
#+end_src

And enable habit module!
#+begin_src elisp
  (add-to-list 'org-modules 'habit t)
#+end_src
** Prettify mode symbols
I have had this part separated but decided to just put it in its right
place now.
#+begin_src elisp
  (add-hook 'org-mode-hook
            'ECFPAW/prettify-symbols-pack/org-checkboxes)
#+end_src
** Babel
=Babel= allows you execute programming languages from within org-mode.
*** languages
Enable babel execution for Python too.
#+begin_src elisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (python . t)))
#+end_src
** Org-Download
This extension allows drag and drop of images.
#+begin_src elisp
  (use-package org-download
    :config
    ;; Drag-and-drop to `dired`
    (add-hook 'dired-mode-hook 'org-download-enable))
#+end_src
** Org custom cookies
Cookies basically give you information about the list.
:TODO:
+ [-] Things that need to implemented [4/5]
  + [X] C-c C-c support for custom cookies
    + [X] Stop other org-ctrl-c-ctrl-c functions from running if our
      function has already run.
  + [X] Face support for custom cookies
  + [X] Add better face support for custom cookies
  + [X] Fix heading color bug.
  + [ ] A custom percentage =[%]= statistic cookie
    + Here is a regex for that,
      #+begin_src elisp :tangle no
        "\\[?\\(?:[0-9]*\\)?\\!%]"
      #+end_src
      It will use the =[!%]= symbol to avoid conflicts with =[%]=.
:END:
#+begin_src elisp
  (use-package org-custom-cookies
    :after org
    :custom (org-custom-cookies-enable-cookie-face t)
    :config
    (advice-add 'org-update-statistics-cookies :after
                'org-custom-cookies--update-all-cookies-current-heading)
    (push '("\\[[.0-9]+\\]"
            . ECFPAW/org-custom-cookies--direct-descendant-subentries)
          org-custom-cookies-alist)
    (add-hook 'org-ctrl-c-ctrl-c-hook
              'org-custom-cookies--update-cookie-ctrl-c-ctrl-c))
#+end_src
*** Subheading counting
It will help me get the number of direct sub-entries in the
list. Through a cookie, to use it, =[D:]= needs to be put at the
heading.
#+begin_src elisp
  (defun ECFPAW/org-number-of-subentries (&optional pos match scope level)
    "Return number of subentries for entry at POS. MATCH and SCOPE are
  the same as for `org-map-entries', but SCOPE defaults to 'tree. By
  default, all subentries are counted; restrict with LEVEL."
    (save-excursion
      (goto-char (or pos (point)))
      ;; If we are in the middle ot an entry, use the current heading.
      (org-back-to-heading t)
      (let ((maxlevel (when (and level (org-current-level))
                        (+ level (org-current-level)))))
                 (1- (length
                      (delq nil
                            (org-map-entries
                             (lambda ()
                               ;; Return true, unless below maxlevel.
                               (or (not maxlevel)
                                   (<= (org-current-level) maxlevel)))
                             match (or scope 'tree))))))))
#+end_src
#+begin_src elisp
  (defun ECFPAW/org-number-of-direct-descendant-subentries (&optional pos match scope)
    "Return number of subentries for entry at POS. MATCH and SCOPE are
  the same as for `org-map-entries', but SCOPE defaults to 'tree. By
  default, only the direct descendant subentries are counted."
    (ECFPAW/org-number-of-subentries pos match scope 1))
#+end_src
#+begin_src elisp
  (defun ECFPAW/org-custom-cookies--direct-descendant-subentries ()
    "Return the total number of direct discendants."
    (format "[%s]" (ECFPAW/org-number-of-direct-descendant-subentries)))
#+end_src
* NEWS-TICKER
=newsticker= is a feed reader for Emacs. 
** Loading feeds
To keep the feeds private, I have the feeds listed in a file called
=feeds.el=.

To remove this from your =git= tracking use this,
#+begin_src shell :tangle no
git update-index --assume-unchanged feed.el
#+end_src

#+begin_src elisp
  (load-file
   (expand-file-name
    "feed.el"
    user-emacs-directory))
#+end_src
** Making eww the default
#+begin_src elisp
  (setq browse-url-browser-function 'eww-browse-url)
#+end_src
* GIT
[[https://git-scm.com][Git]] is the best version control system(The only one I have ever
used). You can use it for anything BTW, not just programming. For
instance when writing stories, its convenient to have Git manage the
versions for you.
** MAGIT
Magit (Maggot , magic IDK) is a git client for Emacs.
#+begin_src elisp
  (use-package transient)
  (use-package magit :ensure t :defer t)
#+end_src
** PINENTRY
For getting support for GPG(GNU Privacy Guard).

#+begin_src elisp
  (use-package pinentry :config (pinentry-start))
#+end_src

To use, add =allow-emacs-pinentry= to =~/.gnupg/gpg-agent.conf=,
reload the configuration with =gpgconf --reload gpg-agent=.

To enable =gpgsigning= for a repository, run this.
#+begin_src shell :tangle no
  git config --local commit.gpgsign true
#+end_src
* DIFF
** EDIFF
I never realized how useful ediff was. And I think its because the
defaults suck. I got this from Prot's config.
#+begin_src elisp
(use-package ediff
  :ensure nil
  :commands (ediff-buffers ediff-files ediff-buffers3 ediff-files3)
  :init
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  :config
  (setq ediff-keep-variants nil)
  (setq ediff-make-buffers-readonly-at-startup t)
  (setq ediff-merge-revisions-with-ancestor t)
  (setq ediff-show-clashes-only t))
#+end_src
* FLYCHECK
Flycheck can do a lot of stuff including,
- Showing errors in programs,
- Showing spelling errors.
#+begin_src elisp
  (use-package flycheck
    :ensure t
    :defer t
    :init (global-flycheck-mode))
#+end_src
* PROGRAMMING
** ENVRC/DIRENV
I used to use Direnv and then I decided to switch to Guix shell, I was
literally starting an Emacs instance per project by launching Emacs
from inside a Guix shell. But after reading this [[https://rednosehacker.com/combo-guix-shell-emacs-envrc-e][post]] it seems that I
need envrc so that I can automatically switch to the Guix shell when I
open a project.
#+begin_src elisp
(use-package envrc
  :config (envrc-global-mode))
#+end_src

You of course need =direnv= and if you want to use Guix shell. You need
to make file similar to this. You need this in your =.envrc= in project root.
#+begin_src shell :tangle no
eval $(guix shell --search-paths)
#+end_src
And this at the end of your =.bashrc=.
#+begin_src bash :tangle no
eval "$(direnv hook bash)"
#+end_src

*** Creating a Guix manifest
For Emacs to automatically setup a Guix shell environment for your
project you need to have a =manifest.scm= in the project root. To
generate this you may use the following command.
#+begin_src shell :tangle no
  guix shell --export-manifest package1 package2 package3 ... > manifest.scm
#+end_src

** Highlighting Indent Guides
Its helpful to keep track indentation. Since I am trying to reduce the
amount of indentation I do.
#+begin_src elisp
  (use-package highlight-indentation
    :config
    (setq highlight-indentation-set-offset 4))
#+end_src
** Breadcrumbs
Breadcrumbs are the little thingies at the top which show in which
part of the document you are in and in which directory.
#+begin_src elisp
  (use-package breadcrumb
    :ensure (:host github :repo "joaotavora/breadcrumb")
    :config (breadcrumb-mode t))
#+end_src
** Compilation mode
*** Enable colors 
#+begin_src elisp
  (add-hook 'compilation-filter-hook #'ansi-color-compilation-filter)
#+end_src
** Rainbow delimiters
This color codes =()= so that you never miss them.
#+begin_src elisp
  (use-package rainbow-delimiters
    :hook ((prog-mode . rainbow-delimiters-mode)))
#+end_src
** Dev web server
#+begin_src elisp
  (defun ECFPAW/start-python-web-server (port directory)
    "Start a Webserver using Python's http.server module.
  PORT can be provided to specify the port to be used by the server,
  DIRECTORY can be provided to specify a directory for the server's root."
    (interactive "Mport: \nMdirectory: ")
    (async-shell-command
     (format "python -m http.server -d %s" directory)))
#+end_src
** Rainbow mode
*Show the colors!*
#+begin_src elisp
(use-package rainbow-mode :config (add-hook 'prog-mode 'rainbow-mode))
#+end_src
** LANGUAGE MODES
**** Markdown mode
I still use markdown files for =README= and stuff, (sorry [[*ORG-MODE]]).
#+begin_src elisp
  (use-package markdown-mode
    :config
    (markdown-mode))
#+end_src
**** Python
***** PET
#+begin_src elisp
  (use-package pet
    :ensure (:host github :repo "tusharhero/emacs-pet" :branch "emacs-30-fix")
    :config
    (add-hook 'python-base-mode-hook 'pet-mode -10)
    (add-hook 'python-base-mode-hook
              (lambda ()
                (setq-local python-shell-interpreter (format "%sbin/python" (pet-virtualenv-root))
                            lsp-pyright-python-executable-cmd (format "%sbin/python" (pet-virtualenv-root))
                            python-shell-virtualenv-root (pet-virtualenv-root)))))
#+end_src
***** Eglot
:TODO:
+ [ ] The required packages to emacs-pkgbuild.
:END:
#+begin_src elisp
  (setq-default eglot-workspace-configuration
                '((:pylsp . (:configurationSources ["flake8"]
                             :plugins (
                                       :flake8 (:enabled :json-false
                                                :maxLineLength 88)
                                       :black (:enabled t
                                               :line_length 80
                                               :cache_config t))))))

  ;; Open python files in tree-sitter mode.
  (add-to-list 'major-mode-remap-alist '(python-mode . python-ts-mode))
#+end_src
***** Prettify mode symbols
#+begin_src elisp
  (ECFPAW/add-pretty-sym-pack 'python-mode-hook '(ECFPAW/prettify-symbols-pack/in-equalities
                                                  ECFPAW/prettify-symbols-pack/asterik-to-multiplication
                                                  ECFPAW/prettify-symbols-pack/lambda
                                                  ECFPAW/prettify-symbols-pack/pointers))
  (ECFPAW/add-pretty-sym-pack 'python-ts-mode-hook '(ECFPAW/prettify-symbols-pack/in-equalities
                                                     ECFPAW/prettify-symbols-pack/asterik-to-multiplication
                                                     ECFPAW/prettify-symbols-pack/lambda
                                                     ECFPAW/prettify-symbols-pack/pointers))
#+end_src
**** C
***** Prettify mode symbols
#+begin_src elisp
  (ECFPAW/add-pretty-sym-pack 'c-mode-hook
                              '(ECFPAW/prettify-symbols-pack/in-equalities
                                ECFPAW/prettify-symbols-pack/pointers))
#+end_src
**** C++
***** Prettify mode symbols
#+begin_src elisp
  (ECFPAW/add-pretty-sym-pack 'c++-mode-hook
                              '(ECFPAW/prettify-symbols-pack/in-equalities
                                ECFPAW/prettify-symbols-pack/pointers
                                'ECFPAW/prettify-symbols-pack/redirections))
#+end_src
**** Go
#+begin_src elisp
  (use-package go-mode)
#+end_src
**** Zig
#+begin_src elisp
  (use-package zig-mode)
#+end_src
***** outline mode regexps
#+begin_src elisp
  (add-hook
   'zig-mode-hook
   (lambda nil
     (setq-local

      outline-regexp
      (rx
       (and (* " ")
            (or "_"
  	   "pub" "const"
             "var" "fn"
             "if" "else"
             "while" "for"
             "inline" "switch")))

      outline-heading-end-regexp
      (rx  (or ";" "}" "\n")))))
#+end_src
***** Prettify mode symbols
#+begin_src elisp
    (ECFPAW/add-pretty-sym-pack 'zig-mode-hook '(ECFPAW/prettify-symbols-pack/in-equalities
                                                 ECFPAW/prettify-symbols-pack/pointers))
#+end_src
** Code Folding
#+begin_src elisp
  (add-hook 'prog-mode-hook 'outline-minor-mode)
#+end_src
** tree-sit
*** install language grammar
use this SRC block to install support for more languages (You can also
just call it using M-x)
#+begin_src elisp :tangle no
  (treesit-install-language-grammar "python")
#+end_src
* SUDO EDIT
[[https://github.com/nflath/sudo-edit][sudo-edit]] gives us the ability to open files with sudo privileges or
switch over to editing with sudo privileges if we initially opened the
file without such privileges.

#+begin_src emacs-lisp
(use-package sudo-edit)
#+end_src
* TRAMP
=Tramp= allows you to remote into other machines from within Emacs.
#+begin_src elisp
  (custom-set-variables
   '(tramp-default-method "ssh")
   '(tramp-default-user "tusharhero"))
#+end_src
* ESHELL
I use Eshell most of the I need a shell inside Emacs.
** Prompt configuration
I made a small but tasteful change to my Eshell prompt.
#+begin_src elisp
  (setq eshell-prompt-function
        (lambda ()
          (require 'magit)
          (concat
           (abbreviate-file-name (eshell/pwd))
           " "
           (let ((branch (magit-get-current-branch)))
             (if branch
                 (concat
                  (propertize (format "·õã %s" branch)
                              'face 'magit-branch)
                  " ")))
           (unless (eshell-exit-success-p)
             (format " [%d]" eshell-last-command-status))
           (if (= (file-user-uid) 0) "#" "‚ò∏") " ")))
#+end_src
** Alias
The ~clear~ command doesn't work like you would expect it to. It turns
out I need to alias it to ~clear-scrollback~!
#+begin_src shell :tangle eshell/alias
  alias clear clear-scrollback
  alias ff 'find-file $1'
#+end_src
* Emacs Everywhere
It allows you to use Emacs everywhere. [[https://aur.archlinux.org/packages/kdotool-git][Kdotools]] and [[https://archlinux.org/packages/extra/x86_64/ydotool/][Ydotool]] are needed for KDE.
#+begin_src elisp
  (use-package emacs-everywhere)
#+end_src
