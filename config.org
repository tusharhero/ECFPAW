# -*- after-save-hook: (org-babel-tangle); -*-
#+TITLE: Emacs Config For Programming And Writing (ECFPAW)
#+AUTHOR: tusharhero
#+EMAIL: tusharhero@sdf.org
#+DESCRIPTION: It actually does more than just programming and writing.
#+STARTUP: content
#+PROPERTY: header-args :tangle init.el
* LICENSE NOTICE
  :PROPERTIES:
  :VISIBILITY: folded
  :END:
#+begin_src elisp
;; The GPLv3 License (GPLv3)

;; Copyright ¬© 2023 Tushar Maharana

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.
#+end_src

* TODO CHORES [0/6]
** TODO Use =use-package= properly to reduce startup time.
** TODO Add more key bindings.
*** TODO Add shortcut to bold, italicize, etc. in [[ORG-MODE]].
** TODO Correct the key bindings for annot-list mode.
** TODO Divide this TODO into respective categories in their correct place.
* EARLY-INIT (SUPER EARLY)
** Disable inbuilt package manager
#+begin_src emacs-lisp :tangle early-init.el
  (setq package-enable-at-startup nil)
#+end_src
** Avoid initial eye eating light theme
#+begin_src emacs-lisp :tangle nil
  (setq mode-line-format nil)
  (set-face-attribute 'default nil :background "#000000" :foreground "#ffffff")
  (set-face-attribute 'mode-line nil :background "#000000" :foreground "#ffffff" :box 'unspecified)
  (add-hook 'after-make-frame-functions (lambda ()
                                           (when-let
                                               ((theme (car custom-enabled-themes)))
                                             (enable-theme theme))))
#+end_src
* IMPORTANT PROGRAMS TO LOAD FIRST
** Package Manager
I am going to use [[https://github.com/progfolio/elpaca][Elapaca]] package manager. You might want to check for
the new installer version on their git repository.
#+BEGIN_SRC elisp
(defvar elpaca-installer-version 0.7)
(defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
(defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
(defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
(defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                              :ref nil :depth 1
                              :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                              :build (:not elpaca--activate-package)))
(let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
       (build (expand-file-name "elpaca/" elpaca-builds-directory))
       (order (cdr elpaca-order))
       (default-directory repo))
  (add-to-list 'load-path (if (file-exists-p build) build repo))
  (unless (file-exists-p repo)
    (make-directory repo t)
    (when (< emacs-major-version 28) (require 'subr-x))
    (condition-case-unless-debug err
        (if-let ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                 ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
                                                 ,@(when-let ((depth (plist-get order :depth)))
                                                     (list (format "--depth=%d" depth) "--no-single-branch"))
                                                 ,(plist-get order :repo) ,repo))))
                 ((zerop (call-process "git" nil buffer t "checkout"
                                       (or (plist-get order :ref) "--"))))
                 (emacs (concat invocation-directory invocation-name))
                 ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                       "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                 ((require 'elpaca))
                 ((elpaca-generate-autoloads "elpaca" repo)))
            (progn (message "%s" (buffer-string)) (kill-buffer buffer))
          (error "%s" (with-current-buffer buffer (buffer-string))))
      ((error) (warn "%s" err) (delete-directory repo 'recursive))))
  (unless (require 'elpaca-autoloads nil t)
    (require 'elpaca)
    (elpaca-generate-autoloads "elpaca" repo)
    (load "./elpaca-autoloads")))
(add-hook 'after-init-hook #'elpaca-process-queues)
(elpaca `(,@elpaca-order))
#+END_SRC
** use-package support.
[[https://jwiegley.github.io/use-package/][use-package]] is useful for configuring and installing packages.
#+begin_src elisp
  ;; Install use-package support
  (elpaca elpaca-use-package
    ;; Enable :ensure use-package keyword.
    (elpaca-use-package-mode)
    ;; Assume :ensure t unless otherwise specified.
    (setq elpaca-use-package-by-default t))
  ;; Block until current queue processed.
  (elpaca-wait)
#+end_src
* SET LOCALE
#+begin_src elisp
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+end_src
* CUSTOM
Just a place for some custom functions I defined and don't really fit
into their own category.
** Functions
#+begin_src elisp
  (defun ECFPAW/major-mode-keybinds ()
    "Map major mode keybindings to `C-c'."
    (interactive)
    (setq unread-command-events (listify-key-sequence (kbd "C-c"))))

  ;; Toggle between split windows and a single window
  (defun ECFPAW/toggle-windows-split()
    "Switch back and forth between one window.
  And whatever split of windows we might have in the frame.  The idea is
  to maximize the current buffer, while being able to go back to the
  previous split of windows in the frame simply by calling this command
  again."
    (interactive)
    (if (not(window-minibuffer-p (selected-window)))
        (progn
          (if (< 1 (count-windows))
              (progn
                (window-configuration-to-register ?u)
                (delete-other-windows))
            (jump-to-register ?u)))))

  (defun ECFPAW/make-cyclic-list (list)
    "Create a cyclic list."
    (when list
      (setf (cdr (last list)) list)))

  (defun ECFPAW/is-it-day ()
    "Return a boolean representation of whether its day or not.
  Any time between 6 and 18 is defined as day."
    (interactive)
    (< 6 (decoded-time-hour (decode-time (current-time))) 18))
#+end_src
* Load Evil Mode
Getting evil mode installed because, I was Vim user and I am most
comfortable in those keybindings.
** Some annoyances with evil
#+begin_src elisp
  (setq evil-want-C-u-scroll t) ;; fix C-u scrolling
  (setq evil-undo-system 'undo-redo) ;; fix undo redo system
#+end_src
** Actually load Evil
#+begin_src elisp
  (use-package evil
    :init
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    (setq evil-vsplit-window-right t)
    (setq evil-split-window-below t)
    (evil-mode))
#+end_src
** Additional evil packages
*** Evil collection
#+begin_src elisp
  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))
#+end_src
*** Evil-tutor
#+begin_src elisp
  (use-package evil-tutor)
#+end_src
*** Evil-numbers
#+begin_src elisp
  (use-package evil-numbers :after evil)
#+end_src
** Fixing links follow
Evil binds these stuff to other stuff, so you need to disable it to be
able to follow links.
#+begin_src elisp
  (with-eval-after-load 'evil-maps
    (define-key evil-motion-state-map (kbd "SPC") nil)
    (define-key evil-motion-state-map (kbd "RET") nil)
    (define-key evil-motion-state-map (kbd "TAB") nil))

  (setq org-return-follows-link  t)
#+end_src
** Tweak default Evil bindings
#+begin_src elisp
  (with-eval-after-load 'evil-maps
    (define-key evil-normal-state-map (kbd "{") 'forward-paragraph)
    (define-key evil-normal-state-map (kbd "}") 'backward-paragraph))
#+end_src
** Converting the caps key to an ESC key
Its very convenient to use the =capslock= key as an additional =ESC=
key.
*** Xorg
#+begin_src shell :tangle nil
  setxkbmap -option caps:escape
#+end_src
* DISABLE BELL
It's very annoying to have that bell ringing all the time.
#+begin_src elisp
(setq visible-bell t)
(setq ring-bell-function 'ignore)
#+end_src
* FILES
Make emacs stop littering my directories with backup files üòÑ.
#+begin_src elisp
  (setq backup-directory-alist '("." . ".emacs-file-backups"))
#+end_src
* WHICH-KEY 
=which-key= basically shows the shortcuts you have setup. Its very
useful, because you may not which key you bonded to what.
#+begin_src elisp
  (use-package which-key
    :init
    (which-key-mode 1)
    :config
    (setq
     which-key-side-window-location 'bottom
     which-key-sort-order #'which-key-key-order-alpha
     which-key-sort-uppercase-first nil
     which-key-add-column-padding 1
     which-key-max-display-columns nil
     which-key-min-display-lines 6
     which-key-side-window-slot -10
     which-key-side-window-max-height 0.25
     which-key-idle-delay 0.8
     which-key-max-description-length 25
     which-key-allow-imprecise-window-fit t
     which-key-separator " ‚Üí " )
    )
#+end_src
* GENERAL KEYBINDINGS
I will use general package to create all the keybindings for ECFPAW. I
only make key binds for the stuff I really need(That goes for the
configuration in general as well).

I had to do add all these different headings to get support for
Imenu. But I also am inside a huge =use-package= call.
** Installation and basic config
#+begin_src elisp
  (use-package general
    :config
    (general-evil-setup)

    ;; set up ',' as major mode keybinds key
    (evil-define-key 'normal global-map (kbd ",") 'ECFPAW/major-mode-keybinds)

    ;; set up 'SPC' as the global leader key
    (general-create-definer ECFPAW/leader-keys
      :states '(normal insert visual emacs)
      :keymaps 'override
      :prefix "SPC" ;; set leader
      :global-prefix "M-SPC") ;; access leader in insert mode
#+end_src
** Direct convenient keybindings
#+begin_src elisp
  (ECFPAW/leader-keys
    "SPC" '(execute-extended-command :wk "Execute command")
    "TAB" '(mode-line-other-buffer :wk "Last buffer")
    ;; "c" '(comment-or-uncomment-region :wk "Comment lines")
    "c" '(comment-dwim :wk "Comment lines")
    "'" '(eshell :wk "Toggle vterm")
    "a" '(evil-numbers/inc-at-pt :wk "Increment number")
    "A" '(evil-numbers/dec-at-pt :wk "Decrement number")
    "g" '(magit :wk "Magit")
    "." '(pulsar-pulse-line :wk "Pulse the current line"))
#+end_src
** Help
#+begin_src elisp
  (ECFPAW/leader-keys
    "h" '(:ignore t :wk "Help")
    "h h" '(help :wk "Help Help!")
    "h f" '(describe-function :wk "Describe function")
    "h v" '(describe-variable :wk "Describe variable"))
#+end_src
** Buffer
#+begin_src elisp
  (ECFPAW/leader-keys
    "b" '(:ignore t :wk "buffer")
    "b b" '(beframe-switch-buffer :wk "Switch buffer")
    "b i" '(ibuffer :wk "Ibuffer")
    "b d" '(kill-this-buffer :wk "Kill this buffer")
    "b x" '(kill-this-buffer :wk "Kill this buffer")
    "b n" '(next-buffer :wk "Next buffer")
    "b p" '(previous-buffer :wk "Previous buffer")
    "b r" '(revert-buffer :wk "Revert buffer")
    "b f" '(olivetti-mode :wk "center text and write")
    "b h" '((lambda () (interactive) (switch-to-buffer "*dashboard*")) :wk "dashboard buffer")
    "b s" '((lambda () (interactive) (switch-to-buffer "*scratch*")) :wk "scratch buffer"))
#+end_src
** Window management
#+begin_src elisp
  ;; window management keybindings
  (ECFPAW/leader-keys
    "w" '(:ignore t :wk "Windows")
    ;; Window splits
    "w d" '(evil-window-delete :wk "Close window")
    "w x" '(evil-window-delete :wk "Close window")
    "w s" '(evil-window-split :wk "Horizontal split window")
    "w v" '(evil-window-vsplit :wk "Vertical split window") 
    "w /" '(evil-window-vsplit :wk "Vertical split window")
    "w m" '(ECFPAW/toggle-windows-split :wk "Maximize window")
    ;; Window motions
    "w h" '(windmove-left :wk "Window left")
    "w j" '(windmove-down :wk "Window down")
    "w k" '(windmove-up :wk "Window up")
    "w l" '(windmove-right :wk "Window right")
    "w w" '(other-window :wk "Goto next window"))
  ;; different keybindgings to resize windows.
  (global-set-key (kbd "<C-down>") 'shrink-window)  
  (global-set-key (kbd "<C-up>") 'enlarge-window)  
  (global-set-key (kbd "<C-right>") 'shrink-window-horizontally)  
  (global-set-key (kbd "<C-left>") 'enlarge-window-horizontally)  
 #+end_src
** File 
#+begin_src elisp
  (ECFPAW/leader-keys
    "f" '(:ignore t :wk "files")
    "f f" '(find-file :wk "Find file")
    "f c" '((lambda () (interactive) (find-file (locate-user-emacs-file "config.org"))) :wk "Edit emacs config")
    "f r" '(recentf :wk "Find recent files")
    "f e r" '((lambda () (interactive) (load-file (locate-user-emacs-file "init.el")) (ignore (elpaca-process-queues)))
              :wk "Reload emacs config"))
#+end_src
** Dired 
#+begin_src elisp
  ;; dired related keybindings
  (ECFPAW/leader-keys
    "d" '(:ignore t :wk "Dired")
    "d d" '(dired :wk "Open dired")
    "d j" '(dired-jump :wk "Dired jump to current"))
#+end_src
** News-ticker
#+begin_src elisp
  (ECFPAW/leader-keys
    "N" '(:ignore t :wk "Newsticker")
    "N n" '(newsticker-treeview :wk "Treeview"))
#+end_src
** Spelling
#+begin_src elisp
  (ECFPAW/leader-keys
    "S" '(:ignore t :wk "Spelling")
    "S s" '(flyspell-auto-correct-word :wk "correct the word")
    "S t" '(flyspell-mode :wk "Toggle flyspell(spellchecking)"))
#+end_src
** Frame 
#+begin_src elisp
  (ECFPAW/leader-keys
    "F" '(:ignore t :wk "frame")
    "F t" '(ECFPAW/change-current-transparency-to :wk "change transparency"))
#+end_src
** Bookmarks
#+begin_src elisp
  (ECFPAW/leader-keys
    "B" '(:ignore t :wk "bookmark")
    "B s" '(bookmark-set :wk "bookmark set")
    "B l" '(bookmark-bmenu-list :wk "bookmark list"))
#+end_src
** Insert
#+begin_src elisp
  (ECFPAW/leader-keys
    "i" '(:ignore t :wk "insert")
    "i e" '(emoji-insert :wk "insert emoji")
    "i s" '(yas-insert-snippet :wk "insert snippet"))
#+end_src
** Eval
#+begin_src elisp
  (ECFPAW/leader-keys
    "e" '(:ignore t :wk "Evaluate")
    "e b" '(eval-buffer :wk "Evaluate elisp in buffer")
    "e d" '(eval-defun :wk "Evaluate defun containing or after point")
    "e e" '(eval-expression :wk "Evaluate and elisp expression")
    "e l" '(eval-last-sexp :wk "Evaluate elisp expression before point")
    "e r" '(eval-region :wk "Evaluate elisp in region"))
#+end_src
** Toggling/Cycling
#+begin_src elisp
  (ECFPAW/leader-keys
    "t" '(:ignore t :wk "Toggle/Cycle")
    "t l" '(display-line-numbers-mode :wk "Toggle line numbers")
    "t L" '(ECFPAW/cycle-line-number-type :wk "cycle line number types")
    "t s" '(flyspell-mode :wk "Toggle flyspell(spellchecking)")
    "t T" '(visual-line-mode :wk "Toggle truncated lines")
    "t c" '(outline-minor-mode :wk "enable code-folding")
    "t o" '(org-mode :wk "toggle org-mode")
    "t O" '(olivetti-mode :wk "center text and write")
    "t m" '(ECFPAW/mode-line/cycle-formats :wk "cycle mode line")
    "t t" '(ECFPAW/cycle-my-theme :wk "Cycle through my themes"))
#+end_src
** Org-mode
#+begin_src elisp
  (ECFPAW/leader-keys
    "o" '(:ignore t :wk "org-mode")
    "o o" '(org-mode :wk "toggle org-mode")
    "o r" '(:ignore t :wk "org-roam")
    "o p" '(org-toggle-latex-fragment :wk "toggle latex preview")
    "o i" '(:ignore :wk "insert")
    "o i d" '(ECFPAW/insert-now-timestamp :wk "time stamp")
    "o i i" '(org-download-clipboard :wk "image")
    "o e" '(:ignore :wk "export")
    "o e p" '(org-latex-export-to-pdf :wk "PDF"))
  (evil-define-key 'normal org-mode-map (kbd "SPC o b") org-babel-map)
  (which-key-add-key-based-replacements "SPC o b" "babel")
#+end_src
*** Org-roam
#+begin_src elisp :tangle nil
  (ECFPAW/leader-keys
    "o r l" '(org-roam-buffer-toggle :wk "Buffer Toggle")
    "o r f" '(org-roam-node-find  :wk "Node find")
    "o r g" '(org-roam-graph  :wk "Graph")
    "o r i" '(org-roam-node-insert :wk "Node insert")
    "o r c" '(org-roam-capture :wk "Capture"))
#+end_src
** Programming
#+begin_src elisp
  (ECFPAW/leader-keys
    "p" '(:ignore t :wk "Programming")
    "p e" '(eglot :wk "Turn on eglot")
    "p d" '(eglot-shutdown :wk "shutdown a eglot workspace")
    "p r" '(eglot-rename :wk "eglot-rename")
    "p f" '(eglot-format-buffer :wk "format buffer")


    "p R" '(xref-find-references :wk "Find references")
    "p g" '(xref-find-definitions :wk "go to definitions")
    "p b" '(xref-go-back :wk "Go back to where you were")

    "p c" '(project-compile :wk "compile")
    "p d" '(eldoc :wk "get docs")
    "p i" '(imenu :wk "imenu")
    "p a" '(eldoc :wk "eglot code actions")
    "p F" '(outline-minor-mode :wk "enable code-folding"))
#+end_src
** Narrowing
#+begin_src elisp
  (ECFPAW/leader-keys
    "n" '(:ignore t :wk "Narrowing")
    "n n" '(narrow-to-region :wk "Narrow to region")
    "n w" '(widen :wk "Widen"))
#+end_src
** LLM
#+begin_src emacs-lisp
  (ECFPAW/leader-keys
    "," '(:ignore t :wk "LLM")
    ", a" '(gptel :wk "gptel buffer")
    ;; I need to call gptel with a prefix argument to create a new GPTel buffer.
    ", c" '((lambda () (interactive) (setq current-prefix-arg '(4)) (call-interactively 'gptel)) :wk "create gptel buffer")
    ", m" '(gptel-menu :wk "GPTel Menu")
    ", A" '(gptel-abort :wk "GPTel abort"))
#+end_src
** Last parens
Don't know of a way to get rid of this...
#+begin_src elisp
  )
#+end_src

* GRAPHICS
** ALL THE ICONS 
This is an icon set that can be used with dashboard, dired, ibuffer
and other Emacs programs.
  
BTW, you need to run =all-the-icons-install-fonts=.
#+begin_src emacs-lisp
  (use-package all-the-icons
    :ensure t
    :if (display-graphic-p))

  (use-package all-the-icons-dired
    :hook (dired-mode . (lambda () (all-the-icons-dired-mode t))))
#+end_src

** FONTS
*** setting the fonts face
Defining the various fonts Emacs will use.
#+begin_src elisp
  (add-to-list 'default-frame-alist
               '(font . "Iosevka NF 14"))
#+end_src
*** Zooming In/Out
For =CTRL=/-= zooming shortcuts.
#+begin_src elisp
  (global-set-key (kbd "C-=") 'text-scale-increase)
  (global-set-key (kbd "C--") 'text-scale-decrease)
  (global-set-key (kbd "<C-wheel-up>") 'text-scale-increase)
  (global-set-key (kbd "<C-wheel-down>") 'text-scale-decrease)
#+end_src
** GRAPHICAL USER INTERFACE TWEAKS
Let's make GNU Emacs look a little better.

Mostly just disabling some Emacs features which are for beginners(mostly).
*** Disable Menu bar and Toolbars 
Just too distracting.
#+begin_src elisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
#+end_src
*** Disable the scroll bar
Because they are totally unnecessary and I don't use them. Even if I
ever wanted to use my mouse, I would just use my mouse wheel instead
of this.
#+begin_src elisp
  (scroll-bar-mode -1)
#+end_src
*** Start in maximised mode
#+begin_src elisp
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src
*** Disable comp warnings
#+begin_src elisp
  (custom-set-variables '(warning-suppress-types '((comp))))
#+end_src
** Pulsar
*** Introduction
=Pulsar= provides the sweet *pulsing* of light you see when you switch
you buffers, or go to a place in the buffer. It's super nice for
knowing where you are.

Evaluate this to get a pulse üòÑ.
#+begin_src elisp :tangle nil :results nil
(pulsar-pulse-line)
#+end_src
*** basic setup
#+begin_src elisp
  (use-package pulsar :config
    (setq pulsar-pulse t)
    (setq pulsar-delay 0.2)
    (setq pulsar-iterations 2)
    (setq pulsar-face 'pulsar-magenta)
    (setq pulsar-highlight-face 'pulsar-yellow)
    (add-hook 'next-error-hook #'pulsar-pulse-line)
    (add-hook 'evil-scroll-up #'pulsar-pulse-line)
    (add-hook 'minibuffer-setup-hook #'pulsar-pulse-line)

    ;; integration with the built-in `imenu':
    (add-hook 'imenu-after-jump-hook #'pulsar-recenter-top)
    (add-hook 'imenu-after-jump-hook #'pulsar-reveal-entry)
    (pulsar-global-mode 1))
#+end_src
*** Adding support for some more functions
#+begin_src elisp
  (with-eval-after-load 'pulsar
    (add-to-list 'pulsar-pulse-functions 'evil-scroll-down)
    (add-to-list 'pulsar-pulse-functions 'evil-scroll-up)
    (add-to-list 'pulsar-pulse-functions 'evil-scroll-line-to-center))
#+end_src
** THEME
I use Modus themes.
*** Extra Themes
**** VSCode theme
#+begin_src elisp
  (use-package vscode-dark-plus-theme
    :ensure t)
#+end_src
**** Catpuccin theme
#+begin_src elisp
(use-package catppuccin-theme :ensure t)
#+end_src
**** Ef-themes
#+begin_src elisp
  (use-package ef-themes :ensure t
    :config (ECFPAW/cycle-my-theme))
#+end_src
*** Easy cycling
:TODO:
+ [ ] Figure out a way to automatically wait for the correct package to
  load before running ~ECFPAW/cycle-theme~, I tried doing it using
  this code, but that does not really work.
  #+begin_src elisp :tangle nil
  (with-eval-after-load (car ECFPAW/themes)
    (ECFPAW/cycle-my-theme))
  #+end_src
:END:
I have a custom function for loading and cycling through my preferred themes.
#+begin_src elisp
  (defvar ECFPAW/themes (ECFPAW/make-cyclic-list
                         (list 'ef-night 'modus-vivendi 'modus-operandi 'ef-day 'vscode-dark-plus))
    "A list of the themes I like and use.")

  (advice-add 'load-theme
              :before (lambda (theme &optional no-confirm no-enable)
                        (disable-theme (car custom-enabled-themes))))

  (defun ECFPAW/cycle-my-theme ()
    "Cycle through a list of themes, `ECFPAW/themes'."
    (interactive)
    (load-theme (pop ECFPAW/themes) t))
#+end_src
*** COMMENT Day and night switching
This is used to make theme switch to the light theme at day and the
dark theme at night.
#+begin_src elisp
  (defvar ECFPAW/day-theme 'modus-operandi
    "Theme of choice for the day.")
  (defvar ECFPAW/night-theme 'modus-vivendi
    "Theme of choice for the night.")
  (defun ECFPAW/switch-theme-day-night ()
    (if (ECFPAW/is-it-day)
        (ECFPAW/load-theme ECFPAW/day-theme)
        (ECFPAW/load-theme ECFPAW/night-theme)))
  (ECFPAW/switch-theme-day-night)
  (run-at-time t 3600 'ECFPAW/switch-theme-day-night)
#+end_src
** MODE-LINE
I am going to make my own mode-line, I followed [[https://protesilaos.com/codelog/2023-07-29-emacs-custom-modeline-tutorial/][Prot's tutorial]].
*** Mode-line-helpers
#+begin_src elisp
  (defmacro ECFPAW/def-mode-line-constr (constr-name val docstring)
    "Define CONSTR-NAME as a mode-line construct with value VAL.
  DOCSTRING is used a docstring."
    `(progn (defvar-local ,constr-name ,val ,docstring)
           (put ',constr-name 'risky-local-variable t)))
#+end_src
*** Mode-line formats
#+begin_src elisp
  (defvar ECFPAW/mode-line/default-format
    '("%e"
      mode-line-front-space
      (:propertize
       ("" mode-line-mule-info mode-line-client mode-line-modified mode-line-remote)
       display (min-width (5.0)))
      mode-line-frame-identification mode-line-buffer-identification
      "   "
      mode-line-position
      (vc-mode vc-mode)
      "  "
      mode-line-modes
      mode-line-misc-info mode-line-end-spaces)
    "The vanilla default Emacs mode line format."
    )

  (defvar ECFPAW/mode-line/full-format
    '(
      " "
      ECFPAW/mode-line/major-mode
      " "
      mode-line-buffer-identification
      " "
      "L%l"
      " "
      "%I"
      " "
      "%n"
      " "
      mode-line-misc-info
      " "
      ECFPAW/mode-line/jee-daily-countdown
      " "
      mode-line-modes
      " "
      mode-line-format-right-align
      ""
      ECFPAW/mode-line/time
      " "
      "@"
      ECFPAW/mode-line/title
      )
    "Full mode line format, for when the mode-line has enough space."
    )


  (defvar ECFPAW/mode-line/mini-format
    '(
      " "
      ECFPAW/mode-line/major-mode
      " "
      mode-line-buffer-identification
      " "
      "L%l"
      " "
      "%I"
      " "
      "%n"
      " "
      mode-line-misc-info
      " "
      ECFPAW/mode-line/jee-daily-countdown
      " "
      mode-line-format-right-align
      ""
      ECFPAW/mode-line/time
      " "
      "@@"
      ECFPAW/mode-line/title
      )
    "Mini mode line format, for when the mode-line doesn't have enough space."
    )
  #+end_src
*** Mode-line constructs
#+begin_src elisp
  (ECFPAW/def-mode-line-constr
   ECFPAW/mode-line/title
   '(:eval
     (propertize "ECFPAW"
                 'face 'modus-line
                 'help-echo
                 "Emacs Configuration For Programming And Writing."))
   "Mode line construct to display ECFPAW.")

  (ECFPAW/def-mode-line-constr
   ECFPAW/mode-line/jee-daily-countdown
   '(:eval
     (propertize
      (format "%i"
              (days-between "Jan 25 2024" (current-time-string)))
      'face 'mode-line-emphasis
      'help-echo "Number of days until JEE Mains"
      'mouse-face 'mode-line-highlight))
   "Mode line construct to display the JEE daily countdown üíÄ")

  (ECFPAW/def-mode-line-constr
   ECFPAW/mode-line/major-mode
   '(:eval 
     (propertize
      (capitalize (symbol-name major-mode)) 'face 'modus-line))
   "Mode line construct to display the major mode.")

  (ECFPAW/def-mode-line-constr
   ECFPAW/mode-line/time
   '(:eval
     (propertize
      (format-time-string "%R %a %d-%b-%y")
      'face 'mode-line-emphasis
      'help-echo
      (current-time-string)
      'mouse-face 'mode-line-highlight))
   "Mode line construct to display the time")

  (ECFPAW/def-mode-line-constr
   ECFPAW/mode-line/toolbox-name
   '(:eval
     (propertize
      (substring (shell-command-to-string
                  "cat /run/.containerenv | grep 'name='")
                 6 -2)
      'face 'mode-line-emphasis
      'help-echo
      (purecopy "Current toolbox")
      'mouse-face 'mode-line-highlight))
   "Mode line construct to display current toolbox-name.")
#+end_src
*** Default mode-line, and cycling.
#+begin_src elisp
  (setq-default mode-line-format ECFPAW/mode-line/mini-format)

  (defvar ECFPAW/mode-line/formats
    (ECFPAW/make-cyclic-list
     (list  ECFPAW/mode-line/full-format ECFPAW/mode-line/mini-format ECFPAW/mode-line/default-format))
    "A list of all the modelines available.")

  (defun ECFPAW/mode-line/cycle-formats ()
    "Cycle through line number types."
    (interactive)
    (setq ECFPAW/current-mode-line-format (pop ECFPAW/mode-line/formats))
    (setq mode-line-format ECFPAW/current-mode-line-format)
    (setq-default mode-line-format ECFPAW/current-mode-line-format)
    (setq-local mode-line-format ECFPAW/current-mode-line-format)
    (force-mode-line-update))
  #+end_src
*** Diminish modes
Hide some minor modes, and replace some with emojis‚Ñ¢. 
#+begin_src elisp
  (use-package diminish
    :defer 3
    :config
    (diminish 'flycheck-mode "c‚úî ")
    (diminish 'flyspell-mode "s‚úî ")
    (diminish 'flymake-mode  "m‚úî ")
    (diminish 'helm-mode)
    (diminish 'company-mode " üóíÔ∏èÔ∏è")
    (diminish 'which-key-mode)
    (diminish 'company-box-mode)
    (diminish 'projectile-mode " üóÇÔ∏è")
    (diminish 'org-indent-mode)
    (diminish 'evil-collection-unimpaired-mode)
    (diminish 'auto-fill-function " ‚úÇ")
    (diminish 'visual-line-mode " ‚úÇ")
    (diminish 'blacken-mode " ‚ö´")
    (diminish 'outline-minor-mode " üìç")
    (diminish 'eldoc-mode " üìú"))
#+end_src

** TRANSPARENCY
With Emacs version 29, true transparency has been added.
*** Setting initial transparency
#+begin_src elisp
  (add-to-list 'default-frame-alist '(alpha-background . 100)) ; For all new frames henceforth
#+end_src
*** Function to change the transparency of the current frame.
**** Xorg
I should be modifying =alpha-background= but that doesn't seem to be
going well. So I will modify =alpha= instead. =alpha-background= just
changes the background transparency, =alpha= on the other hand changes
the transparency of the entire buffer. For now the only way to get
background transparency is to modify the variable in the above
function and make a frame unfortunately. 

I use Wayland now. I will disable this.
#+begin_src elisp :tangle nil
  (defun ECFPAW/change-current-transparency-to (alpha-val)
    "Change the transparency to the given value"
    (interactive "nChange transparency: ")
    (set-frame-parameter (selected-frame) 'alpha alpha-val))
#+end_src
**** Wayland
This works only on Wayland, So disable it and enable the block above.
#+begin_src elisp
  (defun ECFPAW/change-current-transparency-to (alpha-val)
    "Change the transparency to the given value"
    (interactive "nChange transparency: ")
    (set-frame-parameter (selected-frame) 'alpha-background alpha-val))
#+end_src
* LINE NUMBERS
I am using this function because sometimes =absolute= line number is
better than =relative=. And I have decided to *NOT* enable these by
default because they are super distracting.
#+begin_src elisp
    (defvar ECFPAW/line-number-list
      (ECFPAW/make-cyclic-list (list 'relative 'absolute))
      "list of line numbers")

    (defun ECFPAW/cycle-line-number-type ()
      "Cycle through line number types"
      (interactive)
      (setq display-line-numbers (pop ECFPAW/line-number-list)))
#+end_src
* LLM-SUPPORT
I like to use Ollama on my local(and remote) computers üòÑ.
** Ollama management
I find myself needing to manage my ollama instances.
*** Get request for emacs
I need a requests library because url is too much of a pain to use.
#+begin_src elisp
  (use-package plz)
#+end_src
*** Get a list of Ollama instances
#+begin_src elisp
  (defun ECFPAW/ollama-get-model-names (ollama-host)
      "Gets the names of models available in OLLAMA-HOST as a list."
      (require 'plz)
      (mapcar (lambda (model) (alist-get 'name model))
              (alist-get 'models
                         (plz 'get
                           (format "http://%s/api/tags" ollama-host)
                           :as #'json-read))))
#+end_src
** GPTEL
*** Configuration
I currently just use Ollama, I have 2 backends defined one of them is
the local Ollama backend which uses the port ~11434~, the other one is
the remote backend, which uses the port ~11435~. You are supposed use
ssh redirection to redirect your remote ollama server to the port ~11435~.

To redirect any port from a remote machine, use the following command:
#+begin_src shell :tangle nil
ssh -L local_port:remote_address:remote_port username@server.com
#+end_src
#+begin_src elisp
  (use-package gptel
    :ensure (:host github :repo "karthink/gptel" :branch "copilot")
    :config
    (setq-default gptel-backend
                  (gptel-make-ollama "Ollama"
                    :host "localhost:11434"
                    :stream t
                    :models (condition-case nil
                                (ECFPAW/ollama-get-model-names "localhost:11434")
                              (plz-error nil))))
  (gptel-make-ollama "Ollama(remote)"
                      :host "localhost:11435"
                      :stream t
                      :models (condition-case nil
                                  (ECFPAW/ollama-get-model-names "localhost:11435")
                                (plz-error nil)))
  (add-hook 'gptel-post-response-functions 'gptel-end-of-response))
#+end_src
*** System Prompts
:TODO:
+ [ ] Perhaps write elisp code extract this info from an org-tree instead.
:END:
#+begin_src elisp
  (setq gptel-directives
        `(
          (default .
  "You are a large language model living in Emacs and a helpful assistant. Respond concisely.")
          (nobullshit .
  "To assist:  Be terse.  Do not offer unprompted advice or clarifications. Speak in specific,
   topic relevant terminology. Do NOT hedge or qualify. Do not waffle. Speak
   directly and be willing to make creative guesses. Explain your reasoning. if you
   don‚Äôt know, say you don‚Äôt know.

   Remain neutral on all topics. Be willing to reference less reputable sources for
   ideas.

   Never apologize.  Ask questions when unsure.")
          (writing .
  "You are a large language model and a writing assistant. Respond concisely.")
          (chat .
  "You are a large language model and a conversation partner. Respond concisely.")
            (programmer .
  "You are a careful programmer.  Provide code and only code as output
  without any additional text, prompt or note.")
            (cliwhiz .
  "You are a command line helper.  Generate command line commands that
  do what is requested, without any additional description or
  explanation.  Generate ONLY the command, I will edit it myself before
  running.")
            (emacser .
  "You are an Emacs maven.  Reply only with the most appropriate
  built-in Emacs command for the task I specify.  Do NOT generate any
  additional description or explanation.")
            (explain .
  "Explain what this code does to a novice programmer.")
            (overtlyrational .
  "You are rationalAI, an extremely rational chatbot. You will always
  take the side of evidence and reason. You will reject any ideas which
  are irrational. You only care about being rational and nothing else.
  You will not give any explanations or clarifications for your position,
  you will talk to the point. You will not claim to hold no position,
  You will hold a position in accordance with reason and evidence ONLY.
  You will NOT write word salads, you will only talk sense.")
  ))
#+end_src
* TOOLBOXES
Toolboxes are containers which can be used to isolate and use
different GNU+Linux distributions easily and without the overhead of
an virtual machine.
#+begin_src elisp
(defun ECFPAW/get-toolboxes-names ()
  "Get a list of all the toolboxes available."
  (require 'tramp)
  (mapcar #'cadr (tramp-toolbox--completion-function "toolbox")))

(defun ECFPAW/open-toolbox (toolbox-name)
  "Open TOOLBOX-NAME's home directory in Dired."
  (interactive
   (list
    (completing-read "Select toolbox: "
                     (ECFPAW/get-toolboxes-names))))
  (dired
   (format "/toolbox:%s:~" toolbox-name)))
#+end_src
* DASHBOARD
** configuration
[[https://github.com/emacs-dashboard/emacs-dashboard][emacs-dashboard]] is an package which allows you to make a nice little
dashboard which comes up when you start Emacs. I also disable the
number lines for this one because it looked ugly. I have disabled the custom
banner image for now as I feel like the default is cooler.
#+begin_src elisp
  (use-package dashboard
    :ensure t 
    :init
    (setq initial-buffer-choice 'dashboard-open)
    (setq dashboard-set-heading-icons t)
    (setq dashboard-set-file-icons t)
    ;; (setq dashboard-startup-banner (locate-user-emacs-file "images/trancendent-gnu.png"))
    (setq dashboard-banner-logo-title
          "ECFPAW: Emacs Configuration For Programming and Writing")
    (setq dashboard-center-content t)
    (setq dashboard-projects-switch-function 'dired)
    (setq dashboard-projects-backend 'project-el)
    (setq dashboard-items '((recents  . 5)
                            (projects . 5)))
    :config
    (setq dashboard-footer-messages
          (append dashboard-footer-messages
                  (list
                   "What is like the org-mode? What can make war against it?"
                   "I teach Quantum Mechanics to toddlers."
                   "STOP HAVING FUN !!! üò†"
                   "Why did the Emacs user switch to Vim? Because they wanted to be able to exit the editor."
                   )))
    (dashboard-setup-startup-hook))
#+end_src
** Widgets
*** List toolboxes
I will use it to get a list of toolbox on by dashboard.
#+begin_src elisp
    (defun ECFPAW/dashboard-widget/toolboxes (list-size)
    "Toolboxes widget for dashboard."
    (dashboard-insert-heading "Toolboxes:"
			      nil
			      (all-the-icons-faicon "laptop"
						    :height 1.2
						    :v-adjust 0.0
						    :face 'dashboard-heading))
    (dashboard-insert-section
     ""
     (ECFPAW/get-toolboxes-names)
     list-size
     nil
     nil
     `(lambda (&rest _)
        (dired
         (format "/toolbox:%s:~" ,el)))
     (format "%s" el)))
#+end_src
* PROJECT
I was using projectile before but then I realized that I don't use
most of its functionality(Basically it was bloated for me). That is
why I have decided to switch to =project.el=, the builtin project
management functionality of Emacs.
#+begin_src elisp
  (setq project-switch-commands 'project-find-dir)
#+end_src
* DIRED
Dired is a file manager within Emacs. It comes builtin. I am disabling
the display additional info by default because I get overwhelmed.
#+begin_src emacs-lisp
  (add-hook 'dired-mode-hook 'dired-hide-details-mode)
#+end_src

Add human readable directory sizes in the directory listing, because,
/well/, *I AM A HUMAN!*
#+begin_src emacs-lisp
  (setopt dired-listing-switches (concat dired-listing-switches "h"))
#+end_src
* BE-FRAMED
=BE-FRAME= divides all the buffers into different frames, basically
different sets of buffers for different frames, it helps avoids making
a big clutter (at least on surface).
#+begin_src elisp
  (use-package beframe :config (beframe-mode 1))
#+end_src
* COMPLETION
** Fido
:TODO:
+ [ ] Add support for spell checking with Fido and ispell.
:END:
I used to use Helm, but I am trying out Fido now.
#+begin_src emacs-lisp
  (fido-mode)
  (fido-vertical-mode)
#+end_src
** Corfu
:TODO:
+ [ ] Fix this corfu error
#+begin_example
Error running timer ‚Äòcorfu--auto-complete-deferred‚Äô: (wrong-number-of-arguments #<subr evil-normalize-keymaps> 4)
#+end_example
+ [ ] Setup the cape extensions properly
+ [X] Foreshadowing completion support for most cases... Basically I
  need this package , https://code.bsdgeek.org/adam/corfu-candidate-overlay
  I need to do a bit more research though because a lot of stuff uses
  my =TAB= key.
:END:
I used to use Company but that had some issue like, dictionary
disabling all the other symbols.

To complete, please use ~C-<tab>~

The following configuration has been copied from this [[https://github.com/Icy-Thought/emacs.d/blob/main/irkalla/site-lisp/editor/coding/init-corfu.el][config]]. (They
helped me with this setup :) )
#+begin_src emacs-lisp
  (use-package corfu
    :preface
    (defun corfu-enable-in-minibuffer ()
      "Enable Corfu in the minibuffer if `completion-at-point' is bound."
      (when (where-is-internal #'completion-at-point (list (current-local-map)))
        (setq-local corfu-echo-delay nil
                    corfu-popupinfo-delay nil)
        (corfu-mode 1)))
    :hook ((elpaca-after-init . global-corfu-mode)
           (minibuffer-setup . corfu-enable-in-minibuffer))
    :custom
    (corfu-cycle t)
    (corfu-preselect t)
    (corfu-count 5)
    (corfu-scroll-margin 5)
    (corfu-separator ?\s)
    (corfu-on-exact-match nil)
    (corfu-preview-current 'insert)
    (corfu-quit-no-match 'separator)
    :config
    (with-eval-after-load 'evil
      (evil-define-key 'insert corfu-mode-map
        (kbd "C-n")       #'corfu-next
        (kbd "C-p")     #'corfu-previous
        (kbd "C-<tab>") #'completion-at-point)))

  (use-package corfu-terminal
    :unless window-system
    :hook (corfu-mode . corfu-terminal-mode))

  ;; :NOTE| Posframe like completion menu
  (use-package corfu-popupinfo
    :ensure nil
    :hook (corfu-mode . corfu-popupinfo-mode)
    :custom (corfu-popupinfo-delay '(0.5 . 0.2)))

  ;; :NOTE| Completion at point through Cape
  (use-package cape
    :preface
    (defun setup-cape-extensions ()
      (dolist (cape-fn '(dict emoji)) ;; keyword file  dabbrev tex emoji elisp-symbol))
        (add-to-list 'completion-at-point-functions (intern (format "cape-%s" cape-fn)))))
    :hook (corfu-mode . setup-cape-extensions))

  (use-package corfu-candidate-overlay
    :after corfu
    :config
    ;; enable corfu-candidate-overlay mode globally
    ;; this relies on having corfu-auto set to nil
    (corfu-candidate-overlay-mode t))
#+end_src
* TEXT
Some stuff which are for text editing in general.
** Electric
*** Electric pairs
Adds the next pair for =(= automatically.
#+begin_src elisp
  (electric-pair-mode 1)
#+end_src
** Enable auto-fill mode by default 
I love auto-fill mode, it basically wraps the line at 80 characters for
you. So that the line is not too big and readable.
#+begin_src elisp
  (add-hook 'text-mode-hook 'auto-fill-mode)
#+end_src
** Prettify mode
*** enabling it globally
#+begin_src elisp
  (setq prettify-symbols-unprettify-at-point t)
  (global-prettify-symbols-mode)
#+end_src
*** Create symbol packs
**** Marco for creating symbol pack
This macro will create a function which can then be hooked to the mode
you want to hook them to üíÄ. My mind is struggling to comprehend that.
#+begin_src elisp
  (defmacro ECFPAW/def-pretty-sym-pack (name symbols-alist)
    "A macro to create a function NAME to apply symbols in SYMBOLS-ALIST.
  The generated function can be hooked to any mode."
    `(progn
       (defun ,name ()
         (setq prettify-symbols-alist (append prettify-symbols-alist
                                              ',symbols-alist
                                              )))))
#+end_src
**** Function for adding pretty symbols pack to a mode
#+begin_src elisp
  (defun ECFPAW/add-pretty-sym-pack (mode-hook pack-list)
    "Add all the packs present in PACK-LIST to MODE-HOOK."
    (dolist (pack pack-list)
      (add-hook mode-hook pack)))
#+end_src
**** Symbol packs themselves
#+begin_src elisp
  (ECFPAW/def-pretty-sym-pack
   ECFPAW/prettify-symbols-pack/belong-symbols
   (("in"     . #x2208)
    ("not in" . #x2209)))

  (ECFPAW/def-pretty-sym-pack
   ECFPAW/prettify-symbols-pack/in-equalities
   (("<="     .  "‚â§" )
    (">="     .  "‚â•" )
    ("=="     .  "‚âü" )
    ("!="     .  "‚â†" )
    ("!="     .  "‚â†" )))

  (ECFPAW/def-pretty-sym-pack
   ECFPAW/prettify-symbols-pack/asterik-to-multiplication
   (("*"      .   "√ó")))

  (ECFPAW/def-pretty-sym-pack
   ECFPAW/prettify-symbols-pack/lambda
   (("lambda" .  955 )))

  (ECFPAW/def-pretty-sym-pack
   ECFPAW/prettify-symbols-pack/function
   (("def"    .  "ùíª")))

  (ECFPAW/def-pretty-sym-pack
   ECFPAW/prettify-symbols-pack/pointers
   (("->"     . "‚Üí ")
    ("=>"     . "‚áí ")
    ("<-"     . "‚Üê ")))

  (ECFPAW/def-pretty-sym-pack
   ECFPAW/prettify-symbols-pack/redirections
   (("<<"     . "‚â™")
    (">>"     . "‚â´")
    ("<<"     . "‚â™")
    (">>"     . "‚â´")))

  (ECFPAW/def-pretty-sym-pack
   ECFPAW/prettify-symbols-pack/org-checkboxes
   (
    ("[ ]" . "‚òê  ")
    ("[-]" . #("‚ñ°‚Äì" 0 2 (composition ((2)))))
    ("[X]" . "‚òë  ")))
#+end_src
** Enable narrow to region
#+begin_src elisp
  (put 'narrow-to-region 'disabled nil)
#+end_src
** For focused writing
#+begin_src elisp
  (use-package olivetti
    :config
    (setq-default olivetti-body-width 80))
#+end_src
* MANUALS
This will solve any issues I have with documentation.
** Woman
Add manpages from all the toolboxes.
#+begin_src elisp
  (require 'woman)
  (setq
   woman-manpath
   (append (mapcar (lambda
		     (toolbox-name)
		     (format "/toolbox:%s:/usr/share/man" toolbox-name))
		   (ECFPAW/get-toolboxes-names))
	   woman-manpath))
#+end_src
** Texinfo
Add info manual from a custom location.
#+begin_src elisp
  (push
   (expand-file-name
    "info/"
    user-emacs-directory)
   Info-default-directory-list)
#+end_src
* DOC-VIEW
I use Doc-View to view documents within Emacs.
#+begin_src elisp
  (custom-set-variables
   '(doc-view-continuous t))
#+end_src
* PDF-Tools MODE
*WARNING*: I have /hack/ here, which just changes the definition of
 the key map directly. I should do it more *properly*. I also directly
 start with follow minor mode instead of starting with the normal mode.
#+begin_src elisp
  (use-package pdf-tools :init (pdf-loader-install)
    :config
    (add-hook 'pdf-annot-list-mode-hook 'pdf-annot-list-follow-minor-mode)
    (setq pdf-annot-list-mode-map
    (let ((km (make-sparse-keymap)))
      (define-key km (kbd "C-c C-f") #'pdf-annot-list-follow-minor-mode)
      (define-key km (kbd "C-<return>") #'pdf-annot-list-display-annotation-from-id)
      km))
    )
#+end_src
* SNIPPETS
Snippets are very useful to quickly insert boilerplate.
#+begin_src elisp
  (use-package yasnippet :config
    (yas-global-mode 1))
  (use-package yasnippet-snippets :after yasnippets)
#+end_src
* ORG-MODE
#+begin_quote
...
What is like the org-mode? What can make war against it?
...
#+end_quote
** Enable spell checking by default
#+begin_src elisp
  (add-hook 'org-mode-hook 'flyspell-mode)
#+end_src
** Inserting time and date
Here I will make a custom function which will help me insert time and date.
#+begin_src elisp
  (defun ECFPAW/insert-now-timestamp()
    "Insert org mode timestamp at point with current date and time."
    (interactive)
    (org-insert-time-stamp (current-time) t))
#+end_src
** Org-indent
It indents the org tree so its nice to look at.
#+begin_src elisp
  (add-hook 'org-mode-hook 'org-indent-mode)
#+end_src
** Enabling Org Superstar
Org-Superstar look nice.
#+begin_src elisp
  (use-package org-superstar
    :config
    (add-hook 'org-mode-hook (lambda () (org-superstar-mode 1)))
    (setq org-superstar-headline-bullets-list '("‚òØ" "‚óã" "‚ú∏" "‚Åñ")))
#+end_src
** Enabling org-tempo
This packages allows shortcuts for source blocks etc.
#+begin_src elisp
  (require 'org-tempo)
#+end_src
***  Fix Electric mode inhibiting tempo
#+begin_src elisp
(add-hook 'org-mode-hook (lambda ()
           (setq-local electric-pair-inhibit-predicate
                   `(lambda (c)
                  (if (char-equal c ?<) t (,electric-pair-inhibit-predicate c))))))
#+end_src
** LaTeX preview
Org-mode can embed directly into the document. Here I am adjusting the
size and rendering method.
#+begin_src elisp
  (custom-set-variables '(org-format-latex-options
                          '(:foreground default :background default :scale 3 :html-foreground "Black" :html-background "Transparent" :html-scale 1 :matchers
                                        ("begin" "$1" "$" "$$" "\\(" "\\["))))
  (setq org-preview-latex-default-process 'imagemagick)
#+end_src
** Latex math support
#+begin_src elisp
  (use-package cdlatex)
  (add-hook 'org-mode-hook #'turn-on-org-cdlatex)
  (defun ECFPAW/org-latex-yas ()
    "Activate org and LaTeX yas expansion in org-mode buffers."
    (yas-minor-mode)
    (yas-activate-extra-mode 'latex-mode))

  (add-hook 'org-mode-hook #'ECFPAW/org-latex-yas)
#+end_src
** COMMENT Roam
I have disabled it for now.
#+begin_src elisp
  (use-package org-roam
    :ensure t
    :custom
    (org-roam-directory (file-truename "~/Documents/roam"))
    :config
    ;; If you're using a vertical completion framework, you might want a more informative completion interface
    (setq org-roam-node-display-template (concat "${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
    (org-roam-db-autosync-mode)
    (setq org-roam-completion-everywhere t)
    ;; If using org-roam-protocol
    (require 'org-roam-protocol))

  (use-package org-roam-ui
    :after org-roam
    ;;         normally we'd recommend hooking orui after org-roam, but since org-roam does not have
    ;;         a hookable mode anymore, you're advised to pick something yourself
    ;;         if you don't care about startup time, use
    ;;  :hook (after-init . org-roam-ui-mode)
    :config
    (setq org-roam-ui-sync-theme t
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start t))
#+end_src
** Capture
#+begin_src elisp
  (setq org-default-notes-file (concat org-directory "/notes.org"))
#+end_src
** Prettify mode symbols
I have had this part separated but decided to just put it in its right
place now.
#+begin_src elisp
  (add-hook 'org-mode-hook
            'ECFPAW/prettify-symbols-pack/org-checkboxes)
#+end_src
** Babel
=Babel= allows you execute programming languages from within org-mode.
*** languages
Enable babel execution for Python too.
#+begin_src elisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (python . t)))
#+end_src
** Org-Download
This extension allows drag and drop of images.
#+begin_src elisp
  (use-package org-download
    :config
    ;; Drag-and-drop to `dired`
    (add-hook 'dired-mode-hook 'org-download-enable))
#+end_src
** Org custom cookies
Cookies basically give you information about the list.
:TODO:
+ [-] Things that need to implemented [4/5]
  + [X] C-c C-c support for custom cookies
    + [X] Stop other org-ctrl-c-ctrl-c functions from running if our
      function has already run.
  + [X] Face support for custom cookies
  + [X] Add better face support for custom cookies
  + [X] Fix heading color bug.
  + [ ] A custom percentage =[%]= statistic cookie
    + Here is a regex for that,
      #+begin_src elisp :tangle nil
        "\\[?\\(?:[0-9]*\\)?\\!%]"
      #+end_src
      It will use the =[!%]= symbol to avoid conflicts with =[%]=.
:END:
#+begin_src elisp
  (use-package org-custom-cookies
    :ensure (:host github :repo "tusharhero/org-custom-cookies")
    :ensure t
    :after org
    :config
    (advice-add 'org-update-statistics-cookies :after
                'org-custom-cookies--update-all-cookies-current-heading)

    (push '("\\[[.0-9]+\\]"
            . ECPFAW/org-custom-cookies--direct-descendant-subentries)
          org-custom-cookies-alist)

    (add-hook 'org-ctrl-c-ctrl-c-hook
              'org-custom-cookies--update-cookie-ctrl-c-ctrl-c)

    (add-hook 'org-font-lock-set-keywords-hook
              'org-custom-cookies--cookie-face-for-all-custom-cookies))
#+end_src
*** Subheading counting
It will help me get the number of direct sub-entries in the
list. Through a cookie, to use it, =[D:]= needs to be put at the
heading.
#+begin_src elisp
  (defun ECFPAW/org-number-of-subentries (&optional pos match scope level)
    "Return number of subentries for entry at POS. MATCH and SCOPE are
  the same as for `org-map-entries', but SCOPE defaults to 'tree. By
  default, all subentries are counted; restrict with LEVEL."
    (save-excursion
      (goto-char (or pos (point)))
      ;; If we are in the middle ot an entry, use the current heading.
      (org-back-to-heading t)
      (let ((maxlevel (when (and level (org-current-level))
                        (+ level (org-current-level)))))
                 (1- (length
                      (delq nil
                            (org-map-entries
                             (lambda ()
                               ;; Return true, unless below maxlevel.
                               (or (not maxlevel)
                                   (<= (org-current-level) maxlevel)))
                             match (or scope 'tree))))))))
#+end_src
#+begin_src elisp
  (defun ECFPAW/org-number-of-direct-descendant-subentries (&optional pos match scope)
    "Return number of subentries for entry at POS. MATCH and SCOPE are
  the same as for `org-map-entries', but SCOPE defaults to 'tree. By
  default, only the direct descendant subentries are counted."
    (ECFPAW/org-number-of-subentries pos match scope 1))
#+end_src
#+begin_src elisp
  (defun ECPFAW/org-custom-cookies--direct-descendant-subentries ()
    "Return the total number of direct discendants."
    (format "[%s]" (ECFPAW/org-number-of-direct-descendant-subentries)))
#+end_src
* NEWS-TICKER
=newsticker= is a feed reader for Emacs. 
** Loading feeds
To keep the feeds private, I have the feeds listed in a file called
=feeds.el=.

To remove this from your =git= tracking use this,
#+begin_src shell :tangle nil
git update-index --assume-unchanged feed.el
#+end_src

#+begin_src elisp
  (load-file
   (expand-file-name
    "feed.el"
    user-emacs-directory))
#+end_src
** Making eww the default
#+begin_src elisp
  (setq browse-url-browser-function 'eww-browse-url)
#+end_src
* GIT
[[https://git-scm.com][Git]] is the best version control system(The only one I have ever
used). You can use it for anything BTW, not just programming. For
instance when writing stories, its convenient to have Git manage the
versions for you.
** MAGIT
Magit (Maggot , magic IDK) is a git client for Emacs.
#+begin_src elisp
  (use-package magit
      :ensure t
      :defer t
      :config
      (setq package-install-upgrade-built-in t)
      (use-package transient :ensure nil)
      (progn (unload-feature 'transient t) (require 'transient)))
#+end_src
** PINENTRY
For getting support for GPG(GNU Privacy Guard).

#+begin_src elisp
  (use-package pinentry :config (pinentry-start))
#+end_src

To use, add =allow-emacs-pinentry= to =~/.gnupg/gpg-agent.conf=,
reload the configuration with =gpgconf --reload gpg-agent=.

To enable =gpgsigning= for a repository, run this.
#+begin_src shell :tangle nil
  git config --local commit.gpgsign true
#+end_src
* FLYCHECK
Flycheck can do a lot of stuff including,
- Showing errors in programs,
- Showing spelling errors.
#+begin_src elisp
  (use-package flycheck
    :ensure t
    :defer t
    :init (global-flycheck-mode))
#+end_src
* PROGRAMMING
** Highlighting Indent Guides
Its helpful to keep track indentation. Since I am trying to reduce the
amount of indentation I do.
#+begin_src elisp
  (use-package highlight-indentation
    :config
    (setq highlight-indentation-set-offset 4))
#+end_src
** Breadcrumbs
Breadcrumbs are the little thingies at the top which show in which
part of the document you are in and in which directory.
#+begin_src elisp
  (use-package breadcrumb
    :ensure (:host github :repo "joaotavora/breadcrumb")
    :config (breadcrumb-mode t))
#+end_src
** Compilation mode
*** Enable colors 
#+begin_src elisp
  (add-hook 'compilation-filter-hook #'ansi-color-compilation-filter)
#+end_src
** Rainbow delimiters
This color codes =()= so that you never miss them.
#+begin_src elisp
  (use-package rainbow-delimiters
    :hook ((prog-mode . rainbow-delimiters-mode)))
#+end_src
** Rainbow mode
*Show the colors!*
#+begin_src elisp
(use-package rainbow-mode :config (add-hook 'prog-mode 'rainbow-mode))
#+end_src
** LANGUAGE MODES
**** Markdown mode
I still use markdown files for =README= and stuff, (sorry [[*ORG-MODE]]).
#+begin_src elisp
  (use-package markdown-mode
    :config
    (markdown-mode))
#+end_src
**** Python
***** PET
#+begin_src elisp
  (use-package pet
    :ensure (:host github :repo "tusharhero/emacs-pet" :branch "emacs-30-fix")
    :config
    (add-hook 'python-base-mode-hook 'pet-mode -10)
    (add-hook 'python-base-mode-hook
              (lambda ()
                (setq-local python-shell-interpreter (format "%sbin/python" (pet-virtualenv-root))
                            lsp-pyright-python-executable-cmd (format "%sbin/python" (pet-virtualenv-root))
                            python-shell-virtualenv-root (pet-virtualenv-root)))))
#+end_src
***** Eglot
:TODO:
+ [ ] The required packages to emacs-pkgbuild.
:END:
#+begin_src elisp
  (setq-default eglot-workspace-configuration
                '((:pylsp . (:configurationSources ["flake8"]
                             :plugins (
                                       :flake8 (:enabled :json-false
                                                :maxLineLength 88)
                                       :black (:enabled t
                                               :line_length 80
                                               :cache_config t))))))

  ;; Open python files in tree-sitter mode.
  (add-to-list 'major-mode-remap-alist '(python-mode . python-ts-mode))
#+end_src
***** Prettify mode symbols
#+begin_src elisp
  (ECFPAW/add-pretty-sym-pack 'python-mode-hook '(ECFPAW/prettify-symbols-pack/in-equalities
                                                  ECFPAW/prettify-symbols-pack/asterik-to-multiplication
                                                  ECFPAW/prettify-symbols-pack/lambda
                                                  ECFPAW/prettify-symbols-pack/pointers))
  (ECFPAW/add-pretty-sym-pack 'python-ts-mode-hook '(ECFPAW/prettify-symbols-pack/in-equalities
                                                     ECFPAW/prettify-symbols-pack/asterik-to-multiplication
                                                     ECFPAW/prettify-symbols-pack/lambda
                                                     ECFPAW/prettify-symbols-pack/pointers))
#+end_src
**** C
***** Prettify mode symbols
#+begin_src elisp
  (ECFPAW/add-pretty-sym-pack 'c-mode-hook
                              '(ECFPAW/prettify-symbols-pack/in-equalities
                                ECFPAW/prettify-symbols-pack/pointers))
#+end_src
**** C++
***** Prettify mode symbols
#+begin_src elisp
  (ECFPAW/add-pretty-sym-pack 'c++-mode-hook
                              '(ECFPAW/prettify-symbols-pack/in-equalities
                                ECFPAW/prettify-symbols-pack/pointers
                                'ECFPAW/prettify-symbols-pack/redirections))
#+end_src
** Code Folding
#+begin_src elisp
  (add-hook 'prog-mode-hook 'outline-minor-mode)
#+end_src
** tree-sit
*** install language grammar
use this SRC block to install support for more languages (You can also
just call it using M-x)
#+begin_src elisp :tangle nil
  (treesit-install-language-grammar "python")
#+end_src
* SUDO EDIT
[[https://github.com/nflath/sudo-edit][sudo-edit]] gives us the ability to open files with sudo privileges or
switch over to editing with sudo privileges if we initially opened the
file without such privileges.

#+begin_src emacs-lisp
  (use-package sudo-edit
    :config
    (ECFPAW/leader-keys
     "f u" '(sudo-edit-find-file :wk "Sudo find file")
     "f U" '(sudo-edit :wk "Sudo edit file")))
#+end_src
* TRAMP
=Tramp= allows you to remote into other machines from within Emacs.
#+begin_src elisp
  (custom-set-variables
   '(tramp-default-method "ssh")
   '(tramp-default-user "tusharhero"))
#+end_src
* EDIT SERVER
Edit server is an extensions which allows you edit text from your
browser in a very integrated way. I use this one right now,
#+begin_src elisp
  (use-package atomic-chrome
      :init (if after-init-time
                (atomic-chrome-start-server)
              (add-hook 'after-init-hook
                        #'(lambda() (atomic-chrome-start-server))))
      :config (setq atomic-chrome-buffer-open-style 'frame))
#+end_src
